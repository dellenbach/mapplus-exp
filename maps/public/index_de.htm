<!DOCTYPE HTML>
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
    <link rel="preconnect" href="https://www.gis-daten.ch" crossorigin>
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
    <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
    <link rel="dns-prefetch" href="//www.gis-daten.ch">
    <link rel="dns-prefetch" href="//cdn.jsdelivr.net">
    <link rel="dns-prefetch" href="//cdnjs.cloudflare.com">
    <title>MAP+ GIS Daten AG</title>
    
    <!-- Critical CSS für Splash Screen - inline für sofortige Anzeige -->
    <style>
        #splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #4b7b81 0%, #3a6268 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 99999;
            transition: opacity 1s ease, visibility 1s ease, transform 1s ease;
        }
        #splash-screen.hidden {
            opacity: 0;
            visibility: hidden;
            transform: scale(1.05);
        }
        #splash-logo {
            position: relative;
            margin-bottom: 10px;
        }
        #splash-logo img {
            width: 200px;
            height: auto;
            filter: brightness(0) invert(1);
        }
        /* Drehender Cube auf dem I von GIS */
        #splash-cube {
            width: 32px;
            height: 32px;
            position: absolute;
            top: -3px;
            left: 50%;
            margin-left: -16px;
            transform-style: preserve-3d;
            animation: splashRotate 1s infinite linear;
        }
        #splash-cube .cube-face {
            position: absolute;
            width: 32px;
            height: 32px;
            backface-visibility: hidden;
        }
        #splash-cube .cube-front { transform: rotateY(0deg) translateZ(16px); background: #e8423f; }
        #splash-cube .cube-back { transform: rotateY(180deg) translateZ(16px); background: #8a0000; }
        #splash-cube .cube-left { transform: rotateY(-90deg) translateZ(16px); background: #8a0000; }
        #splash-cube .cube-right { transform: rotateY(90deg) translateZ(16px); background: #ffe4e4; }
        #splash-cube .cube-top { transform: rotateX(90deg) translateZ(16px); background: #f69f9f; }
        #splash-cube .cube-bottom { transform: rotateX(-90deg) translateZ(16px); background: #8a0000; }
        @keyframes splashRotate {
            from { transform: rotateX(-30deg) rotateY(0deg); }
            to { transform: rotateX(-30deg) rotateY(360deg); }
        }
        #splash-title {
            color: white;
            font-family: 'Roboto', Arial, sans-serif;
            font-size: 42px;
            font-weight: 300;
            letter-spacing: 8px;
            margin-top: 20px;
            margin-bottom: 40px;
        }
        #splash-loader {
            width: 200px;
            height: 4px;
            background: rgba(255,255,255,0.15);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 60px;
            box-shadow: 0 0 10px rgba(255,255,255,0.1);
        }
        #splash-loader-bar {
            width: 30%;
            height: 100%;
            background: linear-gradient(90deg, rgba(255,255,255,0.3), white, rgba(255,255,255,0.3));
            border-radius: 4px;
            animation: loading 1.5s ease-in-out infinite;
            box-shadow: 0 0 8px rgba(255,255,255,0.5);
        }
        @keyframes loading {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(400%); }
        }
    </style>
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v10.6.0/ol.css"
        onerror="this.href='/mapplus-lib/openlayers/v10.6.0-package/ol.css';">

    <!--
	Layout CSS linking a template and custom layout: to be integrated
  -->
    <link rel="stylesheet" type="text/css"
        href="/mapplus-lib/dojo-release/dojo-release-1.17.3/dijit/themes/tundra/tundra.css" />
    <link rel="stylesheet" type="text/css"
        href="/mapplus-lib/dojo-release/dojo-release-1.17.3/dojox/widget/ColorPicker/ColorPicker.css" />
    <link rel="shortcut icon" href="favicon.png?" />
    <!-- google fonts - Roboto als Hauptschrift -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <!--
	Layout CSS dojo FloatingPane module
  -->
    <link rel="stylesheet" href="../core/templates/nwow_floating/css/FloatingPane.css" />
    
    <!--
	Layout CSS dojo Dialog module
  -->
    <link rel="stylesheet" href="../core/templates/nwow_floating/css/Dialog.css" />
    <!--
	Layout CSS Disclaimer module
  -->
    <link rel="stylesheet" href="../core/templates/nwow_floating/css/Disclaimer.css" />
    <!--
	Layout CSS dojo checkboxtree module
  -->
    <link rel="stylesheet" href="../core/templates/nwow_floating/css/InfoWindow.css" />
    <!--
	POI Manager CSS for icons
  -->
    <link rel="stylesheet" href="../core/templates/nwow_floating/css/PoiManager.css" />
    <!--
	Layout CSS classic Layermanager module
  -->
    <link rel="stylesheet" href="../core/templates/nwow_floating/css/ClassicLayerMgr.css" />
    <!--
	ScaleBar CSS
  -->
    <link rel="stylesheet" type="text/css" href="../core/templates/nwow_floating/css/style.css" />
    <!--
	Layout CSS for search params grids
  -->
    <style type="text/css">
        @import "../core/templates/nwow_floating/css/tundraGrid.css";
        @import "/mapplus-lib/dojo-release/dojo-release-1.17.3/dojox/grid/enhanced/resources/tundra/EnhancedGrid.css";
        @import "/mapplus-lib/dojo-release/dojo-release-1.17.3/dojox/grid/enhanced/resources/EnhancedGrid_rtl.css";
    </style>

    <!-- load this javascript before dojo to avoid multidefine error -->
    <!-- jspdf for preview-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- filesaver-js -->
    <script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.12.1/proj4.min.js" crossorigin="anonymous"
        referrerpolicy="no-referrer"></script>
    <script>window.proj4 || document.write('<script src="/mapplus-lib/proj4js/2.12.1/dist/proj4.js">\x3C/script>')</script>
    <script src="//cdn.jsdelivr.net/npm/ol@v10.6.0/dist/ol.js"></script>
    <script>window.ol || document.write('<script src="/mapplus-lib/openlayers/v10.6.0-package/dist/ol.js">\x3C/script>')</script>

    <script type="text/javascript">

        var dojoConfig = {
            parseOnLoad: false,
            isDebug: false,
            baseUrl: "",
            async: true,
            packages: [{
                name: "njs",
                location: "/mapplus-lib/mapplus-dojo/v4.0.0/extended"
            }],
            locale: "de"
        };

        var hideLoader = function () {
            dojo.fadeOut({
                node: "preloader",
                onEnd: function () {
                    dojo.style("preloader", "display", "none");
                }
            }).play();
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
    <script>window.Sortable || document.write('<script src="/mapplus-lib/Sortable/1.15.0/Sortable.min.js">\x3C/script>')</script>
    <script
        data-dojo-config="packages:[{name:'dojo',location:'https://cdnjs.cloudflare.com/ajax/libs/dojo/1.17.3'},{name:'dijit',location:'/mapplus-lib/dojo-release/dojo-release-1.17.3/dijit'},{name:'dojox',location:'/mapplus-lib/dojo-release/dojo-release-1.17.3/dojox'}]"
        data-dojo-config="mblAlwaysHideAddressBar: true"
        src="https://cdnjs.cloudflare.com/ajax/libs/dojo/1.17.3/dojo.js"></script>
    <script>window.define || document.write('<script data-dojo-config= \'packages:[{name:"dojo",location:"/mapplus-lib/dojo-release/dojo-release-1.17.3/dojo"},{name:"dijit",location:"/mapplus-lib/dojo-release/dojo-release-1.17.3/dijit"},{name:"dojox",location:"/mapplus-lib/dojo-release/dojo-release-1.17.3/dojox"}],mblAlwaysHideAddressBar:true\' src="/mapplus-lib/dojo-release/dojo-release-1.17.3/dojo/dojo.js">\x3C/script>')</script>

    <link rel="stylesheet" href="public/css/override.css" />
    <script>
        var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        if ((navigator.userAgent.indexOf("iPad") > -1) || (navigator.platform.indexOf('Mac') > -1)) {
            console.log(navigator.userAgent);
            var ipadCss = document.createElement("link");
            ipadCss.type = "text/css";
            ipadCss.rel = "stylesheet";
            ipadCss.href = "../core/templates/nwow_floating/css/style_ipad.css";
            document.head.appendChild(ipadCss);
        } 
    </script>

</head>

<body class="tundra">
    <!-- Preloader mit Critical Inline CSS für sofortige Anzeige -->
    <style>
      #preloader{position:fixed;top:0;left:0;right:0;bottom:0;width:100%;height:100%;background:rgba(255,255,255,0.95);background-image:none!important;display:flex;align-items:center;justify-content:center;z-index:99999;perspective:200px}
      #preloader .preloader-cube{width:32px;height:32px;position:relative;transform-style:preserve-3d;transform:rotateX(-30deg) rotateY(-30deg);animation:pRotate 1s infinite linear;will-change:transform;backface-visibility:hidden}
      #preloader .preloader-cube .cube-face{position:absolute;width:32px;height:32px;backface-visibility:hidden}
      #preloader .preloader-cube .cube-front{transform:rotateY(0deg) translateZ(16px);background:#f00}
      #preloader .preloader-cube .cube-back{transform:rotateY(180deg) translateZ(16px);background:#8a0000}
      #preloader .preloader-cube .cube-left{transform:rotateY(-90deg) translateZ(16px);background:#8a0000}
      #preloader .preloader-cube .cube-right{transform:rotateY(90deg) translateZ(16px);background:#ffe4e4}
      #preloader .preloader-cube .cube-top{transform:rotateX(90deg) translateZ(16px);background:#f69f9f}
      #preloader .preloader-cube .cube-bottom{transform:rotateX(-90deg) translateZ(16px);background:#8a0000}
      @keyframes pRotate{from{transform:rotateX(-30deg) rotateY(0deg)}to{transform:rotateX(-30deg) rotateY(360deg)}}
    </style>
    <div id="preloader">
      <div class="preloader-cube"><div class="cube-face cube-front"></div><div class="cube-face cube-back"></div><div class="cube-face cube-left"></div><div class="cube-face cube-right"></div><div class="cube-face cube-top"></div><div class="cube-face cube-bottom"></div></div>
    </div>
    <!-- begin modules load: must be done here in body-->

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol-ext/dist/ol-ext.min.css"
        onerror="this.href='mapplus-lib/openlayers/ol-ext/dist/ol-ext.min.css';">
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/ol-ext/dist/ol-ext.min.js"></script>
    <script>window.ol.ext || document.write('<script src="/mapplus-lib/openlayers/ol-ext/dist/ol-ext.min.js">\x3C/script>')</script>

    <script type="text/javascript" src="/mapplus-lib/mapplus-dojo/v4.0.0/common.js"></script>
    <script type="text/javascript" src="/mapplus-lib/mapplus-dojo/v4.0.0/njs.js"></script>
    <script type="text/javascript" src="/mapplus-lib/mapplus-dojo/v4.0.0/layout.js"></script>
    <script type="text/javascript" src="/mapplus-lib/mapplus-dojo/v4.0.0/appmanager.js"></script>
    <script type="text/javascript" src="/mapplus-lib/mapplus-dojo/v4.0.0/search.js"></script>
    <!--     <script type="text/javascript" src="/mapplus-lib/mapplus-dojo/v4.0.0/floatingwindow.js"></script>-->
    <script type="text/javascript" src="/mapplus-lib/mapplus-dojo/v4.0.0/provider/OLPlus/openlayers.js"></script>

    <script type="text/javascript">
        /* Application configuration */
        njs.AppManager.Version = "v4.0.0";
        njs.AppManager.apipath = "/mapplus-lib/mapplus-dojo/";
        njs.AppManager.Provider = "OLPlus";
        njs.AppManager.template = "nwow_floating";
        njs.AppManager.keepalivetimeout = 180000; // millisecs
        njs.AppManager.keepalivepage = "/mapplus-lib/mapplus-dojo/v4.0.0/php/sso/keepalive.php"
    </script>
    <?php print $set_vars?>


    <!-- dojo modules and startup config-->
    <script type="text/javascript" src="public/config/modules.js?v=v4.0.0"></script>
    <!-- end modules load -->


    <div id="disclaimer_copyright" class="njsDisclaimer"></div>
    <!-- TYDAC Disclaimer entfernt -->
    <div id="disclaimer_tips" class="njsDisclaimer"></div>
    <div id="disclaimer_news" class="njsDisclaimer"></div>
    <div id="disclaimer_pdf" class="njsDisclaimer" style='visibility:hidden'></div>

    <!-- Modaler Dialog mit iframe - ohne Rahmen, abgedunkelter Hintergrund -->
    <div id="mapsInfoDialog" data-dojo-type="dijit/Dialog" title="">
        <div class="customRefreshBtn" onclick="refreshIframe()" title="Seite neu laden">↻</div>
        <div class="customBackBtn" onclick="goBackInIframe()">‹</div>
        <div class="customCloseBtn" onclick="closeMapsInfoDialog()">×</div>
        <iframe id="mapsInfoFrame" name="mapsInfoFrame" data-src="/maps/tnet/inframe-maps.html" 
            loading="lazy" sandbox="allow-same-origin allow-scripts" referrerpolicy="no-referrer"
            style="width: 100%; height: 100%; border: none;"></iframe>
    </div>

    <!-- Splash Screen - sofort sichtbar -->
    <div id="splash-screen">
        <div id="splash-logo">
            <img src="/maps/tnet/resources/logo_gis.svg" alt="GIS Daten AG">
            <div id="splash-cube">
                <div class="cube-face cube-front"></div>
                <div class="cube-face cube-back"></div>
                <div class="cube-face cube-left"></div>
                <div class="cube-face cube-right"></div>
                <div class="cube-face cube-top"></div>
                <div class="cube-face cube-bottom"></div>
            </div>
        </div>
        <div id="splash-loader">
            <div id="splash-loader-bar"></div>
        </div>
    </div>


    
    <!-- GIS Header-Leiste -->
    <div id="gis_logo_header"></div>
    
    <!-- Header Toolbar rechts oben -->
    <div id="header_toolbar">
        <!-- Anmelde-Button (nicht angemeldet) -->
        <div id="header_login" title="Anmelden" onclick="window.location.href=window.location.href+'&amp;group=?'">
            <span class="login-text">Anmelden</span>
            <svg class="login-arrow" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
        </div>
        <!-- Abmelde-Bereich (angemeldet) -->
        <div id="header_logout" style="display: none;" title="Abmelden" onclick="doLogout()">
            <svg class="user-icon" viewBox="0 0 24 24"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg>
            <span id="header_username" class="username-text"></span>
            <span class="separator">|</span>
            <span class="logout-text">Abmelden</span>
            <svg class="logout-arrow" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
        </div>
        <!-- News (Glocke) -->
        <div class="toolbar-item" title="News" onclick="window.open('https://www.gis-daten.ch/news-termine/news/', '_blank')">
            <svg viewBox="0 0 24 24"><path d="M12 22c1.1 0 2-.9 2-2h-4c0 1.1.9 2 2 2zm6-6v-5c0-3.07-1.63-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.64 5.36 6 7.92 6 11v5l-2 2v1h16v-1l-2-2zm-2 1H8v-6c0-2.48 1.51-4.5 4-4.5s4 2.02 4 4.5v6z"/></svg>
        </div>
        <!-- Support (Mail) -->
        <div class="toolbar-item" title="Support kontaktieren" onclick="window.open('https://www.gis-daten.ch/ueber-uns/support/', '_blank')">
            <svg viewBox="0 0 24 24"><path d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z"/></svg>
        </div>
        <!-- Hamburger Menü -->
        <div id="header_menu" class="toolbar-item" title="Menü" onclick="toggleHeaderMenu()">
            <svg viewBox="0 0 24 24"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>
            <!-- Dropdown Menü -->
            <div id="header_menu_dropdown" class="menu-dropdown">
                <div class="menu-item" onclick="event.stopPropagation(); openHelp();">
                    <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z"/></svg>
                    <span>Hilfe</span>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Kartenauswahl Button links oben -->
    <div id="header_maps_select" onclick="openMapsInfoDialog()" title="Kartenauswahl öffnen">
        <span class="maps-icon"><img src="/maps/tnet/resources/icon-maps.svg" alt=""></span>
        <span class="maps-text">Karten</span>
    </div>
    
    <!-- Suchfeld im Header (fixed positioniert) -->
    <div id="njs_search_wrapper"></div>
    
    <!-- GIS Logo links oben (SVG + drehender Würfel) -->
    <a id="gis_logo_container" href="https://www.gis-daten.ch" target="_blank" title="GIS Daten AG - Nidwalden Obwalden">
        <img class="gis-logo-svg" src="/maps/tnet/resources/logo_gis.svg" alt="GIS Daten AG">
        <img class="gis-logo-cube" src="/maps/tnet/resources/gis-cube.gif" alt="">
    </a>

    <div id="freepane" style="position: absolute;left:20px;top:20px;z-index: 50;width:340px;">
        <!-- <div id="lselector">
            <select id="langselect" onchange="changemappluslang(this.options[this.selectedIndex].value);">
                <option value="de" selected>de</option>
                <option value="en">en</option>
                <option value="fr">fr</option>
                <option value="it">it</option>
            </select>
        </div> -->
        <div id="leftPaneHeader" class="njsFooter">
            <div id="logoMapPlus"></div>
        </div>


        <div id="spring">
            <!-- ÜBERGEORDNETES MENU -->
            <div id="tp_overview_menu" data-dojo-type="dijit/TitlePane"
                data-dojo-props="title: 'Themenkatalog', open:false" style="padding:0px;margin:0px;">

                <!-- LAYERMANAGER MENU - wird per JS zu Tabs konvertiert -->
                <div id="kantons_container">
                    <div id="tp_layer_menu" data-dojo-type="dijit/TitlePane" data-dojo-props="title: 'Nidwalden', open:false"
                        style="padding:0px;margin:0px;">
                        <div id="layer_menu" data-dojo-type="dijit.layout.ContentPane" title="Titel 1">
                            <div id="njs_main_lyrmgr_wrapper" style="width: 100%;">
                            </div>
                        </div>
                    </div>
                    
                    <div id="tp_layer_menu2" data-dojo-type="dijit/TitlePane" data-dojo-props="title: 'Obwalden', open:false"
                        style="padding:0px;margin:0px;">
                        <div id="layer_menu2" data-dojo-type="dijit.layout.ContentPane" title="Titel 2">
                            <div id="njs_second_lyrmgr_wrapper" style="width: 100%;">
                            </div>
                        </div>
                    </div>
                    <div id="tp_layer_menu3" data-dojo-type="dijit/TitlePane" data-dojo-props="title: 'Bund', open:false"
                        style="padding:0px;margin:0px;">
                        <div id="layer_menu3" data-dojo-type="dijit.layout.ContentPane" title="Titel 3">
                            <div id="njs_third_lyrmgr_wrapper" style="width: 100%;">
                            </div>
                        </div>
                    </div>
                    <div id="tp_layer_menu4" data-dojo-type="dijit/TitlePane" data-dojo-props="title: 'Weitere', open:false"
                        style="padding:0px;margin:0px;">
                        <div id="layer_menu4" data-dojo-type="dijit.layout.ContentPane" title="Titel 4">
                            <div id="njs_forth_lyrmgr_wrapper" style="width: 100%;">
                            </div>
                        </div>
                    </div>
                </div>
            </div>


            <!-- LAYERMANAGER WMS -->
            <div id="tp_wms_menu" data-dojo-type="dijit/TitlePane"
                data-dojo-props="title: 'Externe Kartendienste (WMS)', open:false">
                <div id="wms_menu" dojotype="dijit.layout.ContentPane" title="Externe Kartendienste">
                    <div id="njs_wmsimport_dialog" style="width:100%; height:100%;"></div>
                </div>
            </div>
            <!-- LAYERMANAGER SORT LAYERS -->
            <div id="tp_sort_menu" data-dojo-type="dijit/TitlePane"
                data-dojo-props="title: 'Dargestellte Themen', open:false">
                <div id="sort_menu">
                    <div id="njs_main_lyrsorter_wrapper" style="width: 100%; height:100%; border:0">
                        <div id="main_lyrsorter_txt" style="display:block;text-align: center;">--- Keine Daten
                            ausgewählt ---</div>
                        <ul id="main_lyrsorter" style="list-style-type: none; padding: 0;"></ul>
                    </div>
                </div>
            </div>
            <!-- TOOL MENU -->
            <div id="tp_tools_menu" data-dojo-type="dijit/TitlePane"
                data-dojo-props="title: 'Werkzeuge / Export', open:false">
                <div id="tools_menu">
                    <div id="njs_measure_wrapper"></div>
                    <div id="njs_redlining_wrapper"></div>
                </div>
                <div id="preview_menu" data-dojo-type="dijit/TitlePane"
                    data-dojo-props="title: 'Export PDF / PNG', open:true">
                    <span style="width:100%;text-align:center;display:block;">
                        <button id="btn_htmlprint1_preview"
                            class="dijitReset dijitInline dijitButtonNode dijitButtonExport"
                            style="text-align: center;box-shadow: 0px 1px 2px #999;margin-right: 10px !important;height: 24px !important;min-width:97px">
                            <span class="njsIconButtonVorExport"
                                style="width:18px;height:18px;display:inline-block"></span>
                            <span>Export</span>
                        </button>

                    </span>
                </div>
            </div>

            <!-- PRINT MENU -->
            <div id="tp_print_menu" data-dojo-type="dijit/TitlePane" data-dojo-props="title: 'Drucken', open:false">

                <div id="print_menu" data-dojo-type="dijit/TitlePane"
                    data-dojo-props="title: 'Ausdruck massstäblich', open:true">
                    <div id="njs_print_wrapper" style="width: 100%; height:100%; border:0"></div>
                </div>


            </div>

            <!-- OVERVIEW -->
            <div id="tp_ov_menu" data-dojo-type="dijit/TitlePane" data-dojo-props="title: 'Navigieren', open:false">
                <div id="ovWin"
                    style="border:solid 1px #424A52; display:block; position:relative; right:-1px; bottom:-1px; z-Index:998; width:310px;height:240px;">
                </div>
            </div>

            <!-- FooterPane for coords - versteckt -->
            <div id="footPane_main" class="edgePanel" data-dojo-type="dijit.layout.ContentPane"
                data-dojo-props="region: 'bottom'" style="display:none;">
                <div id="footPane" class="edgePanel" data-dojo-type="dijit.layout.ContentPane"
                    data-dojo-props="region: 'bottom'">
                    <div id="leftPaneFooter" class="njsFooter">
                        <div id="njs_coordinates_wrapper"></div>
                    </div>
                </div>
            </div>
            
            <!-- Panel Zuklapp-Button -->
            <div class="close_switch" title="Panel ein-/ausklappen" onclick="document.getElementById('freepane').classList.toggle('close');"></div>
        </div>

        <!-- Scroll-to-Top Button (Chevron wird via CSS generiert) -->
        <button id="scrollToTopBtn" onclick="scrollSpringToTop()" title="Nach oben"></button>

    </div>





    <div id="NeapoljsContainer" dojotype="dijit.layout.BorderContainer" design="headline" gutters="false"
        style="width:100%; height:100%;">


        <div id="centerPane" class="edgePanel" data-dojo-type="dijit.layout.ContentPane"
            data-dojo-props="region: 'center'">
            <div id="centerPaneLayout" class="demoLayout" data-dojo-type="dijit.layout.BorderContainer"
                data-dojo-props="design: 'headline'" style="margin: 0px;padding: 0px;border: none">
                <div dojotype="dijit.layout.ContentPane" id='mapContainer' region="center" style="overflow:hidden;">
                    <div id="popup" class="ol-popup">
                        <a href="#" id="popup-closer" class="ol-popup-closer"></a>
                        <div id="popup-content"></div>
                    </div>

                    <div id="njs_main_shop_wrapper" style="display:none"></div>
                    <div id="map" class="map-cont" style="height:100%;"></div>
                    
                    <!-- Polygon-Zeichnen Button -->
                    <div id="polygon-tool-btn" class="map-tool-btn" onclick="togglePolygonDraw()" title="Flächenanalyse - Polygon zeichnen">
                        <svg viewBox="0 0 24 24" width="20" height="20">
                            <path fill="none" stroke="currentColor" stroke-width="1.5" d="M4 6L12 3L20 8L18 18L8 20L4 6Z"/>
                            <circle fill="currentColor" cx="4" cy="6" r="2"/>
                            <circle fill="currentColor" cx="12" cy="3" r="2"/>
                            <circle fill="currentColor" cx="20" cy="8" r="2"/>
                            <circle fill="currentColor" cx="18" cy="18" r="2"/>
                            <circle fill="currentColor" cx="8" cy="20" r="2"/>
                        </svg>
                    </div>
                    
                    <!-- Rechtsklick-Kontextmenü -->
                    <div id="map-context-menu" class="context-menu">
                        <div class="context-menu-header">
                            <span id="ctx-coords-display">--</span>
                        </div>
                        <div class="context-menu-item" onclick="ctxCopyCoords('lv95')">
                            <svg viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg>
                            <span>Koordinaten kopieren (LV95)</span>
                        </div>
                        <div class="context-menu-item" onclick="ctxCopyCoords('wgs84')">
                            <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/></svg>
                            <span>Koordinaten kopieren (WGS84)</span>
                        </div>
                        <div class="context-menu-divider"></div>
                        <div class="context-menu-item" onclick="ctxWhatIsHere()">
                            <svg viewBox="0 0 24 24"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/></svg>
                            <span>Was ist hier?</span>
                        </div>
                        <div class="context-menu-item" onclick="ctxZoomHere()">
                            <svg viewBox="0 0 24 24"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14zm.5-7H9v2H7v1h2v2h1v-2h2V9h-2z"/></svg>
                            <span>Hierher zoomen</span>
                        </div>
                        <div class="context-menu-divider"></div>
                        <div class="context-menu-item" onclick="ctxRouteFrom()">
                            <svg viewBox="0 0 24 24"><path d="M2 12l5 5v-4h9v6l7-7-7-7v6H7V7z"/></svg>
                            <span>Route von hier</span>
                        </div>
                        <div class="context-menu-item" onclick="ctxRouteTo()">
                            <svg viewBox="0 0 24 24"><path d="M22 12l-5-5v4H8V5l-7 7 7 7v-6h9v4z"/></svg>
                            <span>Route hierher</span>
                        </div>
                        <div class="context-menu-divider"></div>
                        <div class="context-menu-item" onclick="ctxOpenGoogleMaps()">
                            <svg viewBox="0 0 24 24"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/></svg>
                            <span>In Google Maps öffnen</span>
                        </div>
                        <div class="context-menu-item" onclick="ctxOpenStreetView()">
                            <svg viewBox="0 0 24 24"><path d="M12.56 14.33c-.34.27-.56.7-.56 1.17V21h7c1.1 0 2-.9 2-2v-5.98c-.94-.33-1.95-.52-3-.52-2.03 0-3.93.7-5.44 1.83zM12 6c1.93 0 3.5 1.57 3.5 3.5S13.93 13 12 13s-3.5-1.57-3.5-3.5S10.07 6 12 6zM12 2C6.48 2 2 6.48 2 12s4.48 10 10 10h1v-6.5c0-.91.47-1.71 1.19-2.17C15.27 12.54 16.6 12 18 12c1.34 0 2.61.29 3.76.8.16-.59.24-1.21.24-1.8 0-5.52-4.48-10-10-10z"/></svg>
                            <span>StreetView öffnen</span>
                        </div>
                        <div class="context-menu-divider"></div>
                        <div class="context-menu-item" onclick="ctxCopyLink()">
                            <svg viewBox="0 0 24 24"><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"/></svg>
                            <span>Link zu Position kopieren</span>
                        </div>
                        <div class="context-menu-item" onclick="ctxMailLink()">
                            <svg viewBox="0 0 24 24"><path d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z"/></svg>
                            <span>Link zu Position mailen</span>
                        </div>
                    </div>
                    
                    <div id="mainButtonBar"></div>
                    
                    <!-- Map Footer Bar - Durchgehende Leiste unten -->
                    <div id="map-footer-bar">
                        <div class="map-footer-left">
                            <div class="map-footer-scale">
                                <select id="map-scale-select" onchange="setMapScale(this.value)" title="Maßstab wählen">
                                    <option value="100">1:100</option>
                                    <option value="250">1:250</option>
                                    <option value="500">1:500</option>
                                    <option value="1000">1:1'000</option>
                                    <option value="2500">1:2'500</option>
                                    <option value="5000">1:5'000</option>
                                    <option value="10000">1:10'000</option>
                                    <option value="25000" selected>1:25'000</option>
                                    <option value="50000">1:50'000</option>
                                    <option value="100000">1:100'000</option>
                                    <option value="200000">1:200'000</option>
                                    <option value="500000">1:500'000</option>
                                    <option value="1000000">1:1'000'000</option>
                                </select>
                            </div>
                            <div class="map-footer-scalebar">
                                <div id="scale-line"></div>
                            </div>
                        </div>
                        <div class="map-footer-center">
                            <div class="map-footer-item map-coord-system">
                                <select id="map-coord-switch" onchange="switchCoordSystem(this.value)">
                                    <option value="lv95">CH1903+ / LV95</option>
                                    <option value="wgs84">WGS84</option>
                                </select>
                            </div>
                            <div class="map-footer-item">
                                <span class="map-footer-label">Koordinaten (m)</span>
                                <span id="map-coord-display" class="map-footer-value">--</span>
                            </div>
                            <div class="map-footer-item" title="Höhe 1: Geländehöhe&#10;Höhe 2: Oberflächenhöhe&#10;Höhe 3: Objekthöhe">
                                <span class="map-footer-label">Höhe:</span>
                                <span id="map-coord-altitude" class="map-footer-value">--</span>
                            </div>
                            <div class="map-footer-item map-footer-picker" id="map-coord-picker-btn" onclick="toggleCoordPicker()" title="Koordinaten fixieren">
                                <svg viewBox="0 0 24 24" width="14" height="14"><path fill="currentColor" d="M16,12V4H17V2H7V4H8V12L6,14V16H11.2V22H12.8V16H18V14L16,12Z"/></svg>
                            </div>
                        </div>
                        <div class="map-footer-right">
                            <span id="map-footer-copyright">© LK / Swissimage: swisstopo, Übrige Daten GIS Daten AG</span>
                        </div>
                    </div>
                    
                    <div id='mapcontrols_div' style="z-index:99999;">
                        <div id='toggle_coltool1_div' style="visibility: hidden;">
                            <input type="button" class="toggle_coltool" id="btnBW"
                                onclick="njs.AppManager.toggleBaseLayerColor('main','toggle_coltool1',this);">
                        </div>
                        <div style="width: 3px;"></div>
                        <div id='opacitytool1_rangediv' style="height:20px; visibility: hidden; width: 110px;">
                            <input type='range' min='0' max='100' value='0'
                                style="width: 110px; margin-top: -1px !important;" id='opacitytool1_range'
                                oninput="njs.AppManager.setBaseLayerOpacity('main',this.value);"
                                onchange="njs.AppManager.setBaseLayerOpacity('main',this.value);">
                        </div>
                    </div>
                    <!-- <div id="ovWin" style="border:solid 1px #424A52; display:none; position:absolute; right:-1px; bottom:-1px; z-Index:998; width:240px;height:240px;">
                        <div id="overviewDiv" style="width:100%;height:100%;"></div>
                    </div>
                    <div id="ovToggleImg" onClick="njs.Layout.toggle_visibility('ovWin');njs.Layout.toggle_img('ovImg','../core/templates/nwow_floating/img/arrow_tl.png','../core/templates/nwow_floating/img/arrow_br.png')">
                        <img id="ovImg" src="../core/templates/nwow_floating/img/arrow_tl.png" />
                    </div> -->

                    <div id="paneSwitcher" class="edgePanel"
                        style="position: absolute;left: 0px;top: 0px;display: none"></div>

                    <!-- Basemap Selector rechts unten -->
                    <div id="basemap_selector" title="Hintergrundkarte wählen" onclick="toggleBasemapWidget()">
                        <div class="basemap-preview"></div>
                        <span class="basemap-label">Hintergrund</span>
                    </div>

                    <!-- Basemap Widget -->
                    <div id="basemap_widget" class="basemap-widget-hidden">
                        <div class="basemap-widget-header">
                            <span>GRUNDKARTE</span>
                            <button class="basemap-widget-close" onclick="toggleBasemapWidget()">&times;</button>
                        </div>
                        <div class="basemap-widget-content">
                            <!-- Layer Toggles -->
                            <div class="basemap-layer-section">
                                <div class="basemap-layer-row">
                                    <span class="layer-icon">〰</span>
                                    <span class="layer-label">Höhenkurven</span>
                                    <div class="layer-toggle">
                                        <button class="toggle-btn active" data-layer="hoehenkurven" data-value="on">EIN</button>
                                        <button class="toggle-btn" data-layer="hoehenkurven" data-value="off">AUS</button>
                                    </div>
                                </div>
                                <div class="basemap-layer-row">
                                    <span class="layer-icon">⊞</span>
                                    <span class="layer-label">Projektebene</span>
                                    <div class="layer-toggle">
                                        <button class="toggle-btn" data-layer="projektebene" data-value="on">EIN</button>
                                        <button class="toggle-btn active" data-layer="projektebene" data-value="off">AUS</button>
                                    </div>
                                </div>
                                <div class="basemap-layer-row">
                                    <span class="layer-icon">◯</span>
                                    <span class="layer-label">Gemeindegrenzen</span>
                                    <div class="layer-toggle">
                                        <button class="toggle-btn active" data-layer="gemeindegrenzen" data-value="on">EIN</button>
                                        <button class="toggle-btn" data-layer="gemeindegrenzen" data-value="off">AUS</button>
                                    </div>
                                </div>
                                <div class="basemap-layer-row">
                                    <span class="layer-icon">◧</span>
                                    <span class="layer-label">Farbig / Grau</span>
                                    <div class="layer-toggle">
                                        <button class="toggle-btn active" data-layer="farbmodus" data-value="color" 
                                            onclick="njs.AppManager.toggleBaseLayerColor('main','toggle_coltool1',this); this.classList.add('active'); this.nextElementSibling.classList.remove('active');">FARBE</button>
                                        <button class="toggle-btn" data-layer="farbmodus" data-value="grey"
                                            onclick="njs.AppManager.toggleBaseLayerColor('main','toggle_coltool1',this); this.classList.add('active'); this.previousElementSibling.classList.remove('active');">GRAU</button>
                                    </div>
                                </div>
                                <div class="basemap-layer-row">
                                    <span class="layer-label">Transparenz</span>
                                    <input type="range" class="transparency-slider" min="0" max="100" value="0" 
                                        oninput="njs.AppManager.setBaseLayerOpacity('main',this.value); this.nextElementSibling.textContent=this.value;" 
                                        onchange="njs.AppManager.setBaseLayerOpacity('main',this.value);">
                                    <span class="transparency-value">0</span>
                                </div>
                            </div>

                            <!-- Haupt-Basemaps (immer sichtbar) -->
                            <div class="basemap-cards-main">
                                <div class="basemap-card active" data-basemap="swissimage" onclick="njs.AppManager.Maps['main'].changeBaseMap('swissimage');">
                                    <div class="basemap-card-preview orthofoto"></div>
                                    <span class="basemap-card-label">Orthofoto</span>
                                </div>
                                <div class="basemap-card" data-basemap="av_sw" onclick="njs.AppManager.Maps['main'].changeBaseMap('av_sw');">
                                    <div class="basemap-card-preview basisplan"></div>
                                    <span class="basemap-card-label">Basisplan</span>
                                </div>
                                <div class="basemap-card" data-basemap="plan_fuer_grundbuch_bund" onclick="njs.AppManager.Maps['main'].changeBaseMap('plan_fuer_grundbuch_bund');">
                                    <div class="basemap-card-preview grundbuch"></div>
                                    <span class="basemap-card-label">Plan f. Grundbuch</span>
                                </div>
                            </div>

                            <!-- Erweiterte Basemap Auswahl -->
                            <div class="basemap-expand-header">
                                <span class="expand-icon">▶</span> erweitern
                            </div>
                            <div class="basemap-cards">
                                <div class="basemap-card" data-basemap="pk_color" onclick="njs.AppManager.Maps['main'].changeBaseMap('pk_color');">
                                    <div class="basemap-card-preview landeskarte"></div>
                                    <span class="basemap-card-label">Landeskarte</span>
                                </div>
                                <div class="basemap-card" data-basemap="siegfried" onclick="njs.AppManager.Maps['main'].changeBaseMap('siegfried');">
                                    <div class="basemap-card-preview siegfried"></div>
                                    <span class="basemap-card-label">Siegfriedkarten</span>
                                </div>
                                <div class="basemap-card" data-basemap="none" onclick="njs.AppManager.Maps['main'].changeBaseMap('none');">
                                    <div class="basemap-card-preview transparent"></div>
                                    <span class="basemap-card-label">Transparent</span>
                                </div>
                                <div class="basemap-card" data-basemap="leer" onclick="njs.AppManager.Maps['main'].changeBaseMap('leer');">
                                    <div class="basemap-card-preview keine"></div>
                                    <span class="basemap-card-label">Leer</span>
                                </div>
                                <div class="basemap-card" data-basemap="av_color" onclick="njs.AppManager.Maps['main'].changeBaseMap('av_color');">
                                    <div class="basemap-card-preview av-color"></div>
                                    <span class="basemap-card-label">Basisplan farbig</span>
                                </div>
                                <div class="basemap-card" data-basemap="osm" onclick="njs.AppManager.Maps['main'].changeBaseMap('osm');">
                                    <div class="basemap-card-preview osm"></div>
                                    <span class="basemap-card-label">OpenStreetMap</span>
                                </div>
                            </div>
                        </div>
                    </div>

                </div>
                <!-- /map container -->


                <div dojotype="dijit.layout.ContentPane" id='custompaneContainer' class="outer"
                    style="width:440px; -webkit-overflow-scrolling:touch !important; margin: 0px;padding: 0px;border: none;"
                    data-dojo-props="region: 'right', splitter: true">
                    <iframe id="custompaneFrame" src="" height="100%"
                        style="-webkit-overflow-scrolling:touch !important; border:none; width:100%; height:100%;">
                    </iframe>
                    <iframe id="custompaneFrameForm" src="" height="100%"
                        style="-webkit-overflow-scrolling:touch !important;display:none; border:none; width:100%; height:100%;">
                    </iframe>
                    <!-- divert maptips in this area -->
                    <!-- <div id="custompaneDiv"></div> -->
                </div>
                <div dojotype="dijit.layout.ContentPane" id='streetviewContainer' class="outer"
                    style="width:500px; display:none; -webkit-overflow-scrolling:touch !important; margin: 0px;padding: 0px;border: none;"
                    data-dojo-props="region: 'right', splitter: true">
                    <iframe id="streetviewFrame" src="" height="100%"
                        style="border:0px; width:100%; height:calc(100%+1px);">
                    </iframe>
                </div>
            </div>
            <!-- /centerPaneLayout-->
        </div>
        <!-- /centerPane-->
        <!-- End EdgePannel -->
    </div>
    <!-- /NeapoljsContainer -->

    <!-- TNET------------------------->
    <!-- TNET helpers for bookmarks&Co. -->
    <script type="text/javascript" src="/maps/tnet/tnet-mapplus-helpers.js"></script>
    
    <!-- TNET Accordion/Tab-Konverter -->
    <link rel="stylesheet" href="/maps/tnet/tnet_toc.css" />
    <script type="text/javascript" src="/maps/tnet/tnet_toc.js"></script>

    <!-- Panel-Schatten dynamisch positioniert -->
    <script type="text/javascript">
        (function() {
            function initPanelShadow() {
                var freepane = document.getElementById('freepane');
                var closeSwitch = document.querySelector('.close_switch');
                if (!freepane || !closeSwitch) {
                    setTimeout(initPanelShadow, 200);
                    return;
                }
                
                // Schatten-Element erstellen
                var shadow = document.createElement('div');
                shadow.id = 'panelShadow';
                freepane.parentNode.insertBefore(shadow, freepane.nextSibling);
                
                function updateShadow() {
                    var rect = closeSwitch.getBoundingClientRect();
                    var headerTop = 69;
                    var bottom = rect.bottom;
                    var width = rect.width;
                    
                    shadow.style.top = headerTop + 'px';
                    shadow.style.height = (bottom - headerTop) + 'px';
                    shadow.style.width = width + 'px';
                    
                    // Bei geschlossenem Panel: Breite der minimierten Leiste
                    if (freepane.classList.contains('close')) {
                        shadow.style.width = '170px';
                        shadow.style.left = ((340 - 170) / 2) + 'px';
                        shadow.style.borderRadius = '0 0 4px 4px';
                    } else {
                        shadow.style.left = '0px';
                        shadow.style.borderRadius = '0 0 4px 4px';
                    }
                }
                
                // Kontinuierliche Animation mit requestAnimationFrame
                function animateLoop() {
                    updateShadow();
                    requestAnimationFrame(animateLoop);
                }
                animateLoop();
                
                window.addEventListener('resize', updateShadow);
            }
            
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initPanelShadow);
            } else {
                initPanelShadow();
            }
        })();
    </script>

    <!-- Scroll-to-Top Button Logic -->
    <script type="text/javascript">
        // Scroll-to-Top Funktionalität für #spring
        function scrollSpringToTop() {
            var spring = document.getElementById('spring');
            if (spring) {
                spring.scrollTo({ top: 0, behavior: 'smooth' });
            }
        }
        
        // Button ein-/ausblenden basierend auf Scroll-Position
        (function() {
            function initScrollToTop() {
                var spring = document.getElementById('spring');
                var btn = document.getElementById('scrollToTopBtn');
                if (!spring || !btn) {
                    setTimeout(initScrollToTop, 500);
                    return;
                }
                
                spring.addEventListener('scroll', function() {
                    if (spring.scrollTop > 100) {
                        btn.classList.add('visible');
                    } else {
                        btn.classList.remove('visible');
                    }
                });
            }
            
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initScrollToTop);
            } else {
                initScrollToTop();
            }
        })();
    </script>

    <script type="text/javascript">
        // Auto-Start für Bookmark-URLs direkt vor </body>
        (function() {
            console.log('Auto-Start Script geladen');
            
            function startBookmarkFromUrl() {
                var currentPath = window.location.pathname;
                console.log('Prüfe URL:', currentPath);
                
                var match = currentPath.match(/\/maps\/([^\/]+)$/);
                
                if (match && match[1]) {
                    var bookmarkId = match[1];
                    console.log('Bookmark in URL gefunden:', bookmarkId);
                    
                    // Prüfe ob alle benötigten Funktionen verfügbar sind
                    if (typeof window.TnetSetBookmark === 'function' &&
                        window.njs && window.njs.AppManager && 
                        window.njs.AppManager.setMapBookmark &&
                        typeof window.njs.AppManager.infoFloatWinRemoveallItems === 'function') {
                        console.log('Alle Funktionen verfügbar - rufe TnetSetBookmark auf');
                        window.TnetSetBookmark(bookmarkId);
                    } else {
                        console.log('Warte auf vollständiges Laden... (njs.AppManager.infoFloatWinRemoveallItems)');
                        setTimeout(startBookmarkFromUrl, 1500);
                    }
                } else {
                    console.log('Keine Bookmark-ID in URL');
                }
            }
            
            // Starte nach 2 Sekunden
            setTimeout(startBookmarkFromUrl, 4000);
        })();
    </script>

    <script type="text/javascript">
        // Funktionen auf window machen damit sie global erreichbar sind
        var iframeHistory = [];
        var iframeHistoryIndex = -1;
        
        window.setupIframeMonitoring = function() {
            var iframe = document.getElementById("mapsInfoFrame");
            if (iframe) {
                iframe.addEventListener('load', function() {
                    try {
                        var currentUrl = iframe.contentWindow.location.href;
                        if (iframeHistoryIndex === -1 || iframeHistory[iframeHistoryIndex] !== currentUrl) {
                            iframeHistory = iframeHistory.slice(0, iframeHistoryIndex + 1);
                            iframeHistory.push(currentUrl);
                            iframeHistoryIndex = iframeHistory.length - 1;
                        }
                    } catch(e) {
                        console.log("Iframe URL nicht zugänglich (cross-origin)");
                    }
                });
            }
        };
        
        window.openMapsInfoDialog = function() {
            var dialog = dijit.byId("mapsInfoDialog");
            if (dialog) {
                // Toggle: Wenn Dialog offen ist, schliessen
                if (dialog.open) {
                    window.closeMapsInfoDialog();
                    return;
                }
                dialog.show();
                var iframe = document.getElementById("mapsInfoFrame");
                if (iframe) {
                    var lazySrc = iframe.getAttribute('data-src') || '/maps/tnet/inframe-maps.html';
                    if (!iframe.getAttribute('src')) {
                        iframe.src = lazySrc;
                    }
                }
                window.setupIframeMonitoring();
            }
        };
        
        window.closeMapsInfoDialog = function() {
            var dialog = dijit.byId("mapsInfoDialog");
            if (dialog) {
                dialog.hide();
                iframeHistory = [];
                iframeHistoryIndex = -1;
                var iframe = document.getElementById("mapsInfoFrame");
                if (iframe) {
                    // iframe entladen, um Ressourcen freizugeben
                    iframe.removeAttribute('src');
                }
            }
        };
        
        window.goBackInIframe = function() {
            var iframe = document.getElementById("mapsInfoFrame");
            if (!iframe) return;
            
            try {
                iframe.contentWindow.history.back();
            } catch(e) {
                if (iframeHistoryIndex > 0) {
                    iframeHistoryIndex--;
                    iframe.src = iframeHistory[iframeHistoryIndex];
                } else {
                    console.log("Keine vorherige Seite in der History");
                }
            }
        };
        
        window.refreshIframe = function() {
            var iframe = document.getElementById("mapsInfoFrame");
            if (!iframe) return;
            var baseSrc = iframe.getAttribute('data-src') || '/maps/tnet/inframe-maps.html';
            if (!iframe.getAttribute('src')) {
                iframe.src = baseSrc;
            } else {
                var newSrc = baseSrc + (baseSrc.indexOf('?') === -1 ? '?t=' : '&t=') + Date.now();
                iframe.src = newSrc;
            }
        };

        // Basemap Widget Toggle - Kachel wächst zum Widget
        window.toggleBasemapWidget = function() {
            var widget = document.getElementById('basemap_widget');
            var selector = document.getElementById('basemap_selector');
            if (widget && selector) {
                widget.classList.toggle('basemap-widget-hidden');
                selector.classList.toggle('hidden');
            }
        };

        // Login/Logout Status prüfen und anzeigen
        window.updateLoginStatus = function() {
            var loginBtn = document.getElementById('header_login');
            var logoutSection = document.getElementById('header_logout');
            var usernameEl = document.getElementById('header_username');
            
            // Prüfe ob njs.AppManager und auth_user verfügbar
            if (window.njs && njs.AppManager && njs.AppManager.auth_user && njs.AppManager.auth_user !== '') {
                var username = njs.AppManager.auth_user;
                // Angemeldet
                if (loginBtn) loginBtn.style.display = 'none';
                if (logoutSection) logoutSection.style.display = 'flex';
                if (usernameEl) usernameEl.textContent = username;
            } else {
                // Nicht angemeldet
                if (loginBtn) loginBtn.style.display = 'flex';
                if (logoutSection) logoutSection.style.display = 'none';
            }
        };

        // Logout-Funktion
        window.doLogout = function() {
            // Direkte Navigation zur logout.php
            window.location.href = 'logout.php';
        };

        // Hamburger Menü Toggle
        window.toggleHeaderMenu = function() {
            var menu = document.getElementById('header_menu');
            if (menu) {
                menu.classList.toggle('open');
            }
        };

        // Hilfe öffnen
        window.openHelp = function() {
            toggleHeaderMenu(); // Menü schließen
            if (window.njs && njs.AppManager && njs.AppManager.toggleCustomPaneContent) {
                njs.AppManager.toggleCustomPaneContent('help', 'custompane', './core/help/help_de.htm', '', '');
            }
        };

        // Menü schließen bei Klick außerhalb
        document.addEventListener('click', function(e) {
            var menu = document.getElementById('header_menu');
            if (menu && menu.classList.contains('open') && !menu.contains(e.target)) {
                menu.classList.remove('open');
            }
        });

        // Splash Screen ausblenden wenn App bereit
        window.hideSplashScreen = function() {
            var splash = document.getElementById('splash-screen');
            // Anderen Preloader verstecken
            var preloader = document.getElementById('preloader');
            if (preloader) preloader.style.display = 'none';
            
            // streetviewContainer sicher verstecken
            var streetview = document.getElementById('streetviewContainer');
            if (streetview) streetview.style.display = 'none';
            
            if (splash) {
                splash.classList.add('hidden');
                // Nach Animation entfernen
                setTimeout(function() {
                    splash.remove();
                }, 1000);
            }
        };

        // Login-Status beim Laden prüfen und Splash ausblenden
        (function checkAppReady() {
            if (window.njs && njs.AppManager && njs.AppManager.Maps && njs.AppManager.Maps['main']) {
                updateLoginStatus();
                // App ist bereit - Splash ausblenden
                hideSplashScreen();
            } else {
                setTimeout(checkAppReady, 300);
            }
        })();

        // Basemap Widget Interaktion
        document.addEventListener('DOMContentLoaded', function() {
            // Toggle Buttons
            document.querySelectorAll('.layer-toggle .toggle-btn').forEach(function(btn) {
                btn.addEventListener('click', function() {
                    var parent = this.closest('.layer-toggle');
                    parent.querySelectorAll('.toggle-btn').forEach(function(b) {
                        b.classList.remove('active');
                    });
                    this.classList.add('active');
                    // TODO: Hier Layer ein/ausschalten
                    console.log('Layer:', this.dataset.layer, 'Value:', this.dataset.value);
                });
            });

            // Basemap Cards - Aktiv-Status setzen
            document.querySelectorAll('.basemap-card').forEach(function(card) {
                card.addEventListener('click', function() {
                    // Alle Cards deaktivieren (auch in main und expanded)
                    document.querySelectorAll('.basemap-card').forEach(function(c) {
                        c.classList.remove('active');
                    });
                    this.classList.add('active');
                });
            });

            // Expand Header
            var expandHeader = document.querySelector('.basemap-expand-header');
            if (expandHeader) {
                expandHeader.addEventListener('click', function() {
                    var cards = document.querySelector('.basemap-cards');
                    var icon = this.querySelector('.expand-icon');
                    if (cards) {
                        cards.classList.toggle('expanded');
                        icon.textContent = cards.classList.contains('expanded') ? '▼' : '▶';
                    }
                });
            }
        });

        // FloatingPane (Maptips Dialog) unter Header positionieren
        (function() {
            var headerHeight = 69;
            var minTop = 80;
            
            function adjustPanePosition(pane) {
                if (!pane) return;
                var top = parseInt(pane.style.top) || 0;
                if (top < headerHeight) {
                    pane.style.top = minTop + 'px';
                }
            }
            
            // Observer für das ganze Dokument - fängt neue Elemente ab
            var bodyObserver = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    if (mutation.type === 'childList') {
                        mutation.addedNodes.forEach(function(node) {
                            if (node.nodeType === 1 && node.classList && 
                                node.classList.contains('dojoxFloatingPane')) {
                                adjustPanePosition(node);
                                // Observer für Style-Änderungen auf diesem Pane
                                var styleObserver = new MutationObserver(function() {
                                    adjustPanePosition(node);
                                });
                                styleObserver.observe(node, { attributes: true, attributeFilter: ['style'] });
                            }
                        });
                    }
                });
            });
            bodyObserver.observe(document.body, { childList: true, subtree: true });
            
            // Bestehende Panes auch behandeln
            document.querySelectorAll('.dojoxFloatingPane').forEach(function(pane) {
                adjustPanePosition(pane);
                var styleObserver = new MutationObserver(function() {
                    adjustPanePosition(pane);
                });
                styleObserver.observe(pane, { attributes: true, attributeFilter: ['style'] });
            });
        })();

        // Preload des iFrames bei erster Nutzerinteraktion
        (function(){
            var preloaded = false;
            function preloadMapsInfoIframe(){
                if (preloaded) return;
                var iframe = document.getElementById('mapsInfoFrame');
                if (!iframe) return;
                var lazySrc = iframe.getAttribute('data-src') || '/maps/tnet/inframe-maps.html';
                if (!iframe.getAttribute('src')) {
                    iframe.src = lazySrc;
                }
                preloaded = true;
            }
            var opts = { once: true, passive: true };
            document.addEventListener('pointerdown', preloadMapsInfoIframe, opts);
            document.addEventListener('keydown', preloadMapsInfoIframe, opts);
            document.addEventListener('touchstart', preloadMapsInfoIframe, opts);
            document.addEventListener('mouseover', preloadMapsInfoIframe, opts);
        })();

        // ===== KOORDINATEN-LEISTE AUF DER KARTE =====
        (function() {
            console.log('Footer Bar Script gestartet');
            var currentCoordSystem = 'lv95';
            
            // Koordinaten-System umschalten
            window.switchCoordSystem = function(system) {
                currentCoordSystem = system;
                updateCoordDisplay();
            };
            
            // Picker toggle (Koordinaten fixieren)
            // Wenn aktiv = Koordinaten sind FIXIERT (laufen nicht mit)
            // Wenn inaktiv = Koordinaten laufen mit Mauszeiger
            window.toggleCoordPicker = function() {
                var btn = document.getElementById('map-coord-picker-btn');
                
                // Original CoordDisplay Picker aufrufen
                if (njs && njs.AppManager && njs.AppManager.Tools && 
                    njs.AppManager.Tools.CoordDisplay && 
                    njs.AppManager.Tools.CoordDisplay['map'] && 
                    njs.AppManager.Tools.CoordDisplay['map']['coord2']) {
                    njs.AppManager.Tools.CoordDisplay['map']['coord2'].togglePicker('map');
                }
                
                // Button-Status aus dem Original-Picker synchronisieren
                setTimeout(function() {
                    var pickerBtn = document.getElementById('coord2_picker');
                    if (pickerBtn && btn) {
                        // Wenn original Picker "Checked" hat, ist er aktiv (fixiert)
                        if (pickerBtn.classList.contains('njsIconButtonCoordPickerChecked')) {
                            btn.classList.add('active');
                        } else {
                            btn.classList.remove('active');
                        }
                    }
                }, 50);
            };
            
            // Initialen Status synchronisieren
            function syncPickerStatus() {
                var btn = document.getElementById('map-coord-picker-btn');
                var pickerBtn = document.getElementById('coord2_picker');
                if (pickerBtn && btn) {
                    if (pickerBtn.classList.contains('njsIconButtonCoordPickerChecked')) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                }
            }
            
            // Koordinaten-Anzeige aktualisieren
            function updateCoordDisplay() {
                var coordDisplay = document.getElementById('map-coord-display');
                var lv95Input = document.getElementById('xy_coord2');
                var wgs84Input = document.getElementById('xy_coord3');
                
                if (!coordDisplay) return;
                
                if (currentCoordSystem === 'lv95' && lv95Input) {
                    coordDisplay.textContent = lv95Input.value || '--';
                } else if (currentCoordSystem === 'wgs84' && wgs84Input) {
                    coordDisplay.textContent = wgs84Input.value || '--';
                }
            }
            
            // Höhen-Anzeige aktualisieren
            function updateAltitudeDisplay() {
                var altDisplay = document.getElementById('map-coord-altitude');
                var altInput = document.getElementById('z_alti1');
                
                if (altDisplay && altInput) {
                    var val = altInput.value;
                    if (val) {
                        // Entferne m.ü.M und andere Texte, behalte nur Zahlen und | 
                        val = val.replace(/m\.?ü\.?M\.?/gi, '').trim();
                    }
                    altDisplay.textContent = val ? val : '--';
                }
            }
            
            // Observer für Änderungen an den Original-Inputs
            function setupObservers() {
                console.log('Footer Bar: setupObservers aufgerufen');
                
                // Debug: Was ist verfügbar?
                console.log('njs:', typeof njs);
                if (njs) {
                    console.log('njs.AppManager:', typeof njs.AppManager);
                    if (njs.AppManager) {
                        console.log('njs.AppManager.Maps:', njs.AppManager.Maps);
                        if (njs.AppManager.Maps && njs.AppManager.Maps['main']) {
                            console.log('Maps[main]:', njs.AppManager.Maps['main']);
                            console.log('Maps[main].map:', njs.AppManager.Maps['main'].map);
                            console.log('Maps[main] keys:', Object.keys(njs.AppManager.Maps['main']));
                        }
                    }
                }
                
                var lv95Input = document.getElementById('xy_coord2');
                var wgs84Input = document.getElementById('xy_coord3');
                var altInput = document.getElementById('z_alti1');
                
                // Warte auf Map statt auf Inputs
                if (!njs || !njs.AppManager || !njs.AppManager.Maps || !njs.AppManager.Maps['main'] || !njs.AppManager.Maps['main'].mapObj) {
                    // Map noch nicht da, später nochmal versuchen
                    console.log('Footer Bar: Map noch nicht bereit, warte 500ms...');
                    setTimeout(setupObservers, 500);
                    return;
                }
                
                console.log('Footer Bar: Map gefunden!');
                var map = njs.AppManager.Maps['main'].mapObj;
                var view = map.getView();
                console.log('Footer Bar: View:', view);
                
                // Initialen Picker-Status synchronisieren
                syncPickerStatus();
                
                // Initiales Update
                updateScaleDisplay();
                updateCopyrightDisplay();
                
                // Event-Listener für Zoom/Resolution-Änderungen
                view.on('change:resolution', updateScaleDisplay);
                
                // Auch bei Bewegung aktualisieren (für den Fall)
                map.on('moveend', updateScaleDisplay);
                
                console.log('Map Footer Bar: Scale Listener registriert auf View', view);
                
                // Polling für Koordinaten und andere Updates (nur wenn Picker nicht fixiert)
                setInterval(function() {
                    updateCoordDisplay();
                    updateAltitudeDisplay();
                    syncPickerStatus();
                }, 500);
                
                console.log('Map Footer Bar: Initialisiert');
            }
            
            // Maßstab berechnen (korrekt mit Projektion)
            function getMapScale(map) {
                var view = map.getView();
                var resolution = view.getResolution();
                var projection = view.getProjection();
                
                if (!resolution || !projection) return null;
                
                // Meter pro Pixel unter Berücksichtigung der Projektion
                var metersPerPixel = resolution * projection.getMetersPerUnit();
                
                // DPI-Konstante (96 dpi): 1 inch = 0.0254 m
                var DPI = 96;
                var inchesPerMeter = 39.37;
                
                // Maßstab 1 : N
                var scale = metersPerPixel * inchesPerMeter * DPI;
                return Math.round(scale);
            }
            
            // Vordefinierte Maßstäbe für die Auswahl
            var predefinedScales = [100, 250, 500, 1000, 2500, 5000, 10000, 25000, 50000, 100000, 200000, 500000, 1000000];
            
            // Resolution aus Maßstab berechnen (umgekehrte Formel)
            function getResolutionFromScale(scale) {
                if (!njs || !njs.AppManager || !njs.AppManager.Maps || !njs.AppManager.Maps['main'] || !njs.AppManager.Maps['main'].mapObj) return null;
                var map = njs.AppManager.Maps['main'].mapObj;
                var view = map.getView();
                var projection = view.getProjection();
                
                var DPI = 96;
                var inchesPerMeter = 39.37;
                var metersPerUnit = projection.getMetersPerUnit();
                
                // scale = resolution * metersPerUnit * inchesPerMeter * DPI
                // resolution = scale / (metersPerUnit * inchesPerMeter * DPI)
                var resolution = scale / (metersPerUnit * inchesPerMeter * DPI);
                return resolution;
            }
            
            // Maßstab setzen (Zoom ändern)
            window.setMapScale = function(scaleValue) {
                var scale = parseInt(scaleValue);
                if (!scale) return;
                
                var resolution = getResolutionFromScale(scale);
                if (!resolution) return;
                
                var map = njs.AppManager.Maps['main'].mapObj;
                var view = map.getView();
                
                // Sanft zum neuen Zoom animieren
                view.animate({
                    resolution: resolution,
                    duration: 250
                });
            };
            
            // Nächsten vordefinierten Maßstab finden
            function findClosestScale(actualScale) {
                var closest = predefinedScales[0];
                var minDiff = Math.abs(actualScale - closest);
                
                for (var i = 1; i < predefinedScales.length; i++) {
                    var diff = Math.abs(actualScale - predefinedScales[i]);
                    if (diff < minDiff) {
                        minDiff = diff;
                        closest = predefinedScales[i];
                    }
                }
                return closest;
            }
            
            // Maßstab im Footer aktualisieren (Dropdown)
            function updateScaleDisplay() {
                var scaleSelect = document.getElementById('map-scale-select');
                if (!scaleSelect) {
                    console.log('Scale: Element #map-scale-select nicht gefunden');
                    return;
                }
                
                if (njs && njs.AppManager && njs.AppManager.Maps && njs.AppManager.Maps['main'] && njs.AppManager.Maps['main'].mapObj) {
                    var map = njs.AppManager.Maps['main'].mapObj;
                    var scale = getMapScale(map);
                    
                    if (!scale) {
                        console.log('Scale: Konnte Maßstab nicht berechnen');
                        return;
                    }
                    
                    // Nächsten vordefinierten Maßstab finden und im Dropdown auswählen
                    var closestScale = findClosestScale(scale);
                    scaleSelect.value = closestScale.toString();
                } else {
                    console.log('Scale: Map nicht verfügbar');
                }
            }
            
            // Copyright aus disclaimer_copyright übernehmen
            function updateCopyrightDisplay() {
                var copyrightTarget = document.getElementById('map-footer-copyright');
                var copyrightSource = document.getElementById('disclaimer_copyright');
                
                if (copyrightTarget && copyrightSource && copyrightSource.textContent.trim()) {
                    copyrightTarget.textContent = copyrightSource.textContent.trim();
                }
            }
            
            // Initialisieren wenn DOM bereit
            console.log('Footer Bar: Warte auf DOM...');
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', function() {
                    console.log('Footer Bar: DOMContentLoaded');
                    setupObservers();
                });
            } else {
                console.log('Footer Bar: DOM bereits geladen');
                setupObservers();
            }
        })();

        // ===== RECHTSKLICK-KONTEXTMENÜ =====
        (function() {
            var contextMenu = null;
            var ctxCoordsDisplay = null;
            var clickedCoords = null; // {lv95: [E, N], wgs84: [lon, lat], pixel: [x, y]}
            
            // Warte auf Map UND DOM
            function waitForMapAndDOM(callback) {
                var mapReady = njs && njs.AppManager && njs.AppManager.Maps && njs.AppManager.Maps['main'] && njs.AppManager.Maps['main'].mapObj;
                var domReady = document.getElementById('map-context-menu') && document.getElementById('map');
                
                if (mapReady && domReady) {
                    callback(njs.AppManager.Maps['main']);
                } else {
                    setTimeout(function() { waitForMapAndDOM(callback); }, 300);
                }
            }
            
            // Proj4 Transformation LV95 <-> WGS84
            function lv95ToWgs84(e, n) {
                // Vereinfachte Näherung für Schweiz
                var y_aux = (e - 2600000) / 1000000;
                var x_aux = (n - 1200000) / 1000000;
                
                var lon = 2.6779094 
                    + 4.728982 * y_aux 
                    + 0.791484 * y_aux * x_aux 
                    + 0.1306 * y_aux * Math.pow(x_aux, 2) 
                    - 0.0436 * Math.pow(y_aux, 3);
                
                var lat = 16.9023892 
                    + 3.238272 * x_aux 
                    - 0.270978 * Math.pow(y_aux, 2) 
                    - 0.002528 * Math.pow(x_aux, 2) 
                    - 0.0447 * Math.pow(y_aux, 2) * x_aux 
                    - 0.0140 * Math.pow(x_aux, 3);
                
                lon = lon * 100 / 36;
                lat = lat * 100 / 36;
                
                return [lon, lat];
            }
            
            // Toast anzeigen
            function showToast(message) {
                var existing = document.querySelector('.ctx-toast');
                if (existing) existing.remove();
                
                var toast = document.createElement('div');
                toast.className = 'ctx-toast';
                toast.textContent = message;
                document.body.appendChild(toast);
                
                setTimeout(function() {
                    toast.classList.add('fade-out');
                    setTimeout(function() { toast.remove(); }, 300);
                }, 2000);
            }
            
            // Menü ausblenden
            window.hideContextMenu = function() {
                if (contextMenu) contextMenu.classList.remove('show');
            };
            
            // Gemeinsame Marker-Funktion (wird von Linksklick UND Kontextmenü verwendet)
            function setMarkerAtPosition(coords) {
                if (!coords || !coords.lv95) return;
                
                if (njs && njs.AppManager && njs.AppManager.Maps && njs.AppManager.Maps['main']) {
                    var mapWrapper = njs.AppManager.Maps['main'];
                    var map = mapWrapper.mapObj;
                    
                    if (!map || typeof ol === 'undefined') return;
                    
                    // Marker-Layer erstellen falls nicht vorhanden
                    if (!window.userMarkerLayer) {
                        window.userMarkerLayer = new ol.layer.Vector({
                            source: new ol.source.Vector(),
                            zIndex: 999
                        });
                        map.addLayer(window.userMarkerLayer);
                    }
                    
                    // Alten Marker entfernen (nur ein aktiver Marker)
                    window.userMarkerLayer.getSource().clear();
                    
                    // Marker-Style mit externem SVG-Pin
                    var markerStyle = new ol.style.Style({
                        image: new ol.style.Icon({
                            anchor: [0.5, 70],
                            anchorXUnits: 'fraction',
                            anchorYUnits: 'pixels',
                            src: '/maps/tnet/resources/icons/marker-pin.svg',
                            scale: 0.75
                        })
                    });
                    
                    var feature = new ol.Feature({
                        geometry: new ol.geom.Point(coords.lv95),
                        name: 'Marker',
                        coords: coords
                    });
                    feature.setStyle(markerStyle);
                    
                    window.userMarkerLayer.getSource().addFeature(feature);
                }
            }
            
            // Globale Funktion für externe Aufrufe
            window.setMarkerAtPosition = setMarkerAtPosition;
            
            // Bei Klick außerhalb oder Escape schließen
            document.addEventListener('click', function(e) {
                if (contextMenu && !contextMenu.contains(e.target)) {
                    hideContextMenu();
                }
            });
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') hideContextMenu();
            });
            
            // Map Rechtsklick
            waitForMapAndDOM(function(mapWrapper) {
                contextMenu = document.getElementById('map-context-menu');
                ctxCoordsDisplay = document.getElementById('ctx-coords-display');
                
                var map = mapWrapper.mapObj; // OpenLayers Map
                if (!map) {
                    console.error('Context Menu: OpenLayers map nicht gefunden');
                    return;
                }
                
                var mapEl = document.getElementById('map');
                if (!mapEl) {
                    console.error('Context Menu: Map Element nicht gefunden');
                    return;
                }
                
                console.log('Context Menu: Initialisiert auf', mapEl);
                
                // Event direkt auf das canvas Element mit capture
                function handleContextMenu(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    
                    console.log('Context Menu: Rechtsklick bei', e.clientX, e.clientY);
                    
                    // Pixel-Koordinaten
                    var rect = mapEl.getBoundingClientRect();
                    var pixel = [e.clientX - rect.left, e.clientY - rect.top];
                    
                    // Koordinaten aus Map holen (LV95)
                    var coord = map.getCoordinateFromPixel(pixel);
                    if (!coord) {
                        console.log('Context Menu: Keine Koordinaten');
                        return false;
                    }
                    
                    var lv95 = [Math.round(coord[0]), Math.round(coord[1])];
                    var wgs84 = lv95ToWgs84(coord[0], coord[1]);
                    
                    clickedCoords = {
                        lv95: lv95,
                        wgs84: wgs84,
                        pixel: pixel
                    };
                    
                    // Koordinaten im Header anzeigen
                    if (ctxCoordsDisplay) {
                        ctxCoordsDisplay.textContent = lv95[0].toLocaleString('de-CH') + ' / ' + lv95[1].toLocaleString('de-CH');
                    }
                    
                    console.log('Context Menu: Koordinaten', lv95);
                    
                    // Position des Menüs
                    var menuWidth = 240;
                    var menuHeight = 380;
                    var posX = e.clientX;
                    var posY = e.clientY;
                    
                    // Am rechten Rand anpassen
                    if (posX + menuWidth > window.innerWidth) {
                        posX = window.innerWidth - menuWidth - 10;
                    }
                    // Am unteren Rand anpassen
                    if (posY + menuHeight > window.innerHeight) {
                        posY = window.innerHeight - menuHeight - 10;
                    }
                    
                    contextMenu.style.left = posX + 'px';
                    contextMenu.style.top = posY + 'px';
                    contextMenu.classList.add('show');
                    
                    console.log('Context Menu: Angezeigt');
                    return false;
                }
                
                // Event auf mapEl mit capture:true (fängt Event vor OpenLayers)
                mapEl.addEventListener('contextmenu', handleContextMenu, true);
                
                // Auch auf document als Fallback
                document.addEventListener('contextmenu', function(e) {
                    // Nur wenn innerhalb des Map-Containers
                    if (mapEl.contains(e.target) || e.target === mapEl) {
                        handleContextMenu(e);
                    }
                }, true);
                
                // Linksklick auf Karte: Marker setzen
                map.on('singleclick', function(evt) {
                    // Nicht wenn Polygon-Tool aktiv ist
                    if (window.isPolygonDrawing) return;
                    
                    // Koordinaten aus Event
                    var coord = evt.coordinate;
                    if (!coord) return;
                    
                    var lv95 = [Math.round(coord[0]), Math.round(coord[1])];
                    var wgs84 = lv95ToWgs84(coord[0], coord[1]);
                    
                    var coords = {
                        lv95: lv95,
                        wgs84: wgs84,
                        pixel: evt.pixel
                    };
                    
                    // Marker an Klickposition setzen
                    setMarkerAtPosition(coords);
                });
            });
            
            // Menü-Aktionen
            window.ctxCopyCoords = function(format) {
                if (!clickedCoords) return;
                var text;
                if (format === 'lv95') {
                    // Versuche zuerst aus bestehendem Input-Feld zu lesen
                    var lv95Input = document.getElementById('xy_coord2');
                    if (lv95Input && lv95Input.value) {
                        text = lv95Input.value;
                    } else {
                        text = clickedCoords.lv95[0] + ', ' + clickedCoords.lv95[1];
                    }
                    showToast('LV95 kopiert: ' + text);
                } else {
                    // Versuche zuerst aus bestehendem Input-Feld zu lesen
                    var wgs84Input = document.getElementById('xy_coord3');
                    if (wgs84Input && wgs84Input.value) {
                        text = wgs84Input.value;
                    } else {
                        text = clickedCoords.wgs84[1].toFixed(6) + ', ' + clickedCoords.wgs84[0].toFixed(6);
                    }
                    showToast('WGS84 kopiert: ' + text);
                }
                navigator.clipboard.writeText(text);
                hideContextMenu();
            };
            
            // Koordinaten fixieren (Picker toggle)
            window.ctxFixCoords = function() {
                hideContextMenu();
                // Toggle den CoordDisplay Picker
                if (njs && njs.AppManager && njs.AppManager.Tools && 
                    njs.AppManager.Tools.CoordDisplay && 
                    njs.AppManager.Tools.CoordDisplay['map'] && 
                    njs.AppManager.Tools.CoordDisplay['map']['coord2']) {
                    njs.AppManager.Tools.CoordDisplay['map']['coord2'].togglePicker('map');
                    showToast('Koordinaten-Anzeige fixiert');
                } else {
                    // Fallback: Klick auf Picker-Button simulieren
                    var pickerBtn = document.getElementById('coord2_picker');
                    if (pickerBtn) {
                        pickerBtn.click();
                        showToast('Koordinaten-Anzeige fixiert');
                    }
                }
            };
            
            window.ctxWhatIsHere = function() {
                if (!clickedCoords) return;
                hideContextMenu();
                
                // Marker setzen an der Position
                setMarkerAtPosition(clickedCoords);
                
                // Feature-Info an Position abfragen (simuliere Linksklick)
                if (njs && njs.AppManager && njs.AppManager.Maps && njs.AppManager.Maps['main']) {
                    var mapWrapper = njs.AppManager.Maps['main'];
                    var map = mapWrapper.mapObj;
                    
                    if (map) {
                        // Simuliere singleclick Event an der Position
                        map.dispatchEvent({
                            type: 'singleclick', 
                            coordinate: clickedCoords.lv95, 
                            pixel: clickedCoords.pixel,
                            originalEvent: { preventDefault: function(){}, stopPropagation: function(){} }
                        });
                    }
                }
            };
            
            window.ctxZoomHere = function() {
                if (!clickedCoords) return;
                hideContextMenu();
                if (njs && njs.AppManager && njs.AppManager.Maps && njs.AppManager.Maps['main']) {
                    var map = njs.AppManager.Maps['main'].mapObj;
                    if (map) {
                        var view = map.getView();
                        view.animate({
                            center: clickedCoords.lv95,
                            zoom: Math.max(view.getZoom() + 2, 15),
                            duration: 500
                        });
                    }
                }
            };
            
            window.ctxSetMarker = function() {
                if (!clickedCoords) return;
                hideContextMenu();
                setMarkerAtPosition(clickedCoords);
                showToast('Marker gesetzt');
            };
            
            window.ctxRouteFrom = function() {
                if (!clickedCoords) return;
                hideContextMenu();
                // Routing-Start setzen
                showToast('Start-Position gesetzt: ' + clickedCoords.lv95[0] + ', ' + clickedCoords.lv95[1]);
                window.routeStartCoords = clickedCoords;
                // Falls Routing-Modul vorhanden
                if (njs && njs.AppManager && njs.AppManager.getModule) {
                    var routing = njs.AppManager.getModule('routing');
                    if (routing && routing.setStart) {
                        routing.setStart(clickedCoords.lv95);
                    }
                }
            };
            
            window.ctxRouteTo = function() {
                if (!clickedCoords) return;
                hideContextMenu();
                // Routing-Ziel setzen
                showToast('Ziel-Position gesetzt: ' + clickedCoords.lv95[0] + ', ' + clickedCoords.lv95[1]);
                window.routeEndCoords = clickedCoords;
                // Falls Routing-Modul vorhanden
                if (njs && njs.AppManager && njs.AppManager.getModule) {
                    var routing = njs.AppManager.getModule('routing');
                    if (routing && routing.setEnd) {
                        routing.setEnd(clickedCoords.lv95);
                    }
                }
            };
            
            window.ctxOpenGoogleMaps = function() {
                if (!clickedCoords) return;
                hideContextMenu();
                var lat = clickedCoords.wgs84[1].toFixed(6);
                var lon = clickedCoords.wgs84[0].toFixed(6);
                var url = 'https://www.google.com/maps?q=' + lat + ',' + lon + '&z=18';
                window.open(url, '_blank');
            };
            
            window.ctxOpenStreetView = function() {
                if (!clickedCoords) return;
                hideContextMenu();
                
                // Nutze das bestehende StreetView-Tool von njs
                if (njs && njs.AppManager && njs.AppManager.Tools && njs.AppManager.Tools.StreetView && njs.AppManager.Tools.StreetView['main']) {
                    var svTool = njs.AppManager.Tools.StreetView['main'];
                    var container = document.getElementById('streetviewContainer');
                    var isVisible = container && container.style.display !== 'none' && container.offsetWidth > 0;
                    
                    if (isVisible) {
                        // StreetView ist bereits offen - schliessen und mit neuer Position wieder öffnen
                        svTool.toggleView(false); // Schliessen
                        setTimeout(function() {
                            svTool.toggleView(true); // Mit neuer Position öffnen
                        }, 100);
                    } else {
                        // StreetView ist geschlossen - normal öffnen
                        svTool.toggleView(true);
                    }
                } else {
                    // Fallback: Google StreetView direkt öffnen
                    var lat = clickedCoords.wgs84[1].toFixed(6);
                    var lon = clickedCoords.wgs84[0].toFixed(6);
                    var url = 'https://www.google.com/maps?layer=c&cbll=' + lat + ',' + lon;
                    window.open(url, '_blank');
                }
            };
            
            window.ctxCopyLink = function() {
                hideContextMenu();
                // Einfach die aktuelle URL kopieren (enthält bereits alle Parameter)
                var currentUrl = window.location.href;
                navigator.clipboard.writeText(currentUrl);
                showToast('URL kopiert!');
            };
            
            window.ctxMailLink = function() {
                hideContextMenu();
                var currentUrl = window.location.href;
                var subject = encodeURIComponent('Kartenposition');
                var body = encodeURIComponent('Schau dir diese Position an:\n\n' + currentUrl);
                window.location.href = 'mailto:?subject=' + subject + '&body=' + body;
            };
        })();
        
        // ===== POLYGON-ZEICHNEN UND RÄUMLICHE ABFRAGE =====
        // Globale Variable um Zeichenmodus zu tracken
        window.isPolygonDrawing = false;
        
        (function() {
            var drawInteraction = null;
            var drawLayer = null;
            var isDrawing = false;
            
            // Warte auf Map
            function waitForMap(callback) {
                if (njs && njs.AppManager && njs.AppManager.Maps && njs.AppManager.Maps['main'] && njs.AppManager.Maps['main'].mapObj) {
                    callback(njs.AppManager.Maps['main'].mapObj);
                } else {
                    setTimeout(function() { waitForMap(callback); }, 300);
                }
            }
            
            // Zeichnen-Layer erstellen
            function getDrawLayer(map) {
                if (!drawLayer) {
                    drawLayer = new ol.layer.Vector({
                        source: new ol.source.Vector(),
                        style: new ol.style.Style({
                            fill: new ol.style.Fill({
                                color: 'rgba(75, 123, 129, 0.2)'
                            }),
                            stroke: new ol.style.Stroke({
                                color: '#4b7b81',
                                width: 2,
                                lineDash: [5, 5]
                            }),
                            image: new ol.style.Circle({
                                radius: 5,
                                fill: new ol.style.Fill({ color: '#4b7b81' }),
                                stroke: new ol.style.Stroke({ color: 'white', width: 2 })
                            })
                        }),
                        zIndex: 1000
                    });
                    map.addLayer(drawLayer);
                }
                return drawLayer;
            }
            
            // Polygon-Zeichnen aktivieren/deaktivieren
            window.togglePolygonDraw = function() {
                waitForMap(function(map) {
                    var btn = document.getElementById('polygon-tool-btn');
                    var panel = document.getElementById('spatial-query-panel');
                    var statusEl = document.getElementById('spatial-query-status');
                    var resultsEl = document.getElementById('spatial-query-results');
                    
                    if (isDrawing) {
                        // Deaktivieren
                        if (drawInteraction) {
                            map.removeInteraction(drawInteraction);
                            drawInteraction = null;
                        }
                        isDrawing = false;
                        window.isPolygonDrawing = false;
                        document.body.classList.remove('drawing-mode');
                        btn.classList.remove('active');
                        panel.classList.add('hidden');
                        
                        // Layer leeren
                        if (drawLayer) {
                            drawLayer.getSource().clear();
                        }
                    } else {
                        // Aktivieren
                        var layer = getDrawLayer(map);
                        layer.getSource().clear();
                        
                        drawInteraction = new ol.interaction.Draw({
                            source: layer.getSource(),
                            type: 'Polygon',
                            style: new ol.style.Style({
                                fill: new ol.style.Fill({
                                    color: 'rgba(75, 123, 129, 0.1)'
                                }),
                                stroke: new ol.style.Stroke({
                                    color: '#4b7b81',
                                    width: 2,
                                    lineDash: [5, 5]
                                }),
                                image: new ol.style.Circle({
                                    radius: 5,
                                    fill: new ol.style.Fill({ color: '#4b7b81' }),
                                    stroke: new ol.style.Stroke({ color: 'white', width: 2 })
                                })
                            })
                        });
                        
                        drawInteraction.on('drawend', function(evt) {
                            var polygon = evt.feature.getGeometry();
                            var coords = polygon.getCoordinates()[0];
                            
                            // Zeichenmodus beenden
                            isDrawing = false;
                            window.isPolygonDrawing = false;
                            document.body.classList.remove('drawing-mode');
                            
                            // DrawInteraction sofort entfernen damit normale Klicks wieder funktionieren
                            waitForMap(function(map) {
                                if (drawInteraction) {
                                    map.removeInteraction(drawInteraction);
                                    drawInteraction = null;
                                }
                            });
                            
                            // Abfrage starten
                            statusEl.textContent = 'Abfrage läuft...';
                            resultsEl.innerHTML = '<div class="loading-spinner"></div>';
                            
                            // Räumliche Abfrage ausführen
                            executeSpatialQuery(coords);
                            
                            // Zeichnen beenden
                            setTimeout(function() {
                                map.removeInteraction(drawInteraction);
                                drawInteraction = null;
                            }, 100);
                        });
                        
                        map.addInteraction(drawInteraction);
                        isDrawing = true;
                        window.isPolygonDrawing = true;
                        document.body.classList.add('drawing-mode');
                        btn.classList.add('active');
                        panel.classList.remove('hidden');
                        statusEl.textContent = 'Zeichnen Sie ein Polygon auf der Karte (Doppelklick zum Beenden)...';
                        resultsEl.innerHTML = '';
                    }
                });
            };
            
            // Panel schließen
            window.closeSpatialQueryPanel = function() {
                var panel = document.getElementById('spatial-query-panel');
                var btn = document.getElementById('polygon-tool-btn');
                panel.classList.add('hidden');
                btn.classList.remove('active');
                isDrawing = false;
                window.isPolygonDrawing = false;
                document.body.classList.remove('drawing-mode');
                
                // Freepane zurücksetzen falls Panel angedockt war
                var freepane = document.getElementById('freepane');
                if (freepane) {
                    freepane.classList.remove('panel-docked');
                    freepane.style.bottom = '';
                }
                window.isPanelDocked = false;
                
                waitForMap(function(map) {
                    if (drawInteraction) {
                        map.removeInteraction(drawInteraction);
                        drawInteraction = null;
                    }
                    if (drawLayer) {
                        drawLayer.getSource().clear();
                    }
                });
            };
            
            // ===== INFO PANE ERWEITERUNGEN =====
            // Buttons zum Info-Panel hinzufügen und Resize aktivieren
            // Verwendet MutationObserver um auch bei Neuöffnen zu funktionieren
            (function initInfoPaneEnhancements() {
                
                function enhanceInfoPane() {
                    var infoPane = document.getElementById('njs_info_pane');
                    if (!infoPane) return false;
                    
                    var titleBar = infoPane.querySelector('.dojoxFloatingPaneTitle');
                    if (!titleBar) return false;
                    
                    // Prüfe ob Actions bereits vorhanden
                    if (titleBar.querySelector('.info-pane-actions')) {
                        // Actions vorhanden - aber Resize-Handles prüfen
                        if (!infoPane.querySelector('.info-pane-resize-left')) {
                            initInfoPaneResize(infoPane);
                        }
                        return true;
                    }
                    
                    // Actions Container erstellen
                    var actions = document.createElement('div');
                    actions.className = 'info-pane-actions';
                    
                    // Clipboard Button
                    var clipboardBtn = document.createElement('button');
                    clipboardBtn.className = 'info-pane-btn';
                    clipboardBtn.title = 'In Zwischenablage kopieren';
                    clipboardBtn.innerHTML = '<svg viewBox="0 0 24 24"><path fill="currentColor" d="M19 21H8V7h11m0-2H8a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2m-3-4H4a2 2 0 0 0-2 2v14h2V3h12V1Z"/></svg>';
                    clipboardBtn.onclick = function(e) {
                        e.stopPropagation();
                        copyInfoPaneToClipboard();
                    };
                    
                    // Dock Button
                    var dockBtn = document.createElement('button');
                    dockBtn.className = 'info-pane-btn';
                    dockBtn.id = 'info-pane-dock-btn';
                    dockBtn.title = 'Rechts andocken';
                    dockBtn.innerHTML = '<svg viewBox="0 0 24 24"><path fill="currentColor" d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16h-4V5h4v14z"/></svg>';
                    dockBtn.onclick = function(e) {
                        e.stopPropagation();
                        toggleInfoPaneDock();
                    };
                    
                    // Close Button (custom, da original versteckt)
                    var closeBtn = document.createElement('button');
                    closeBtn.className = 'info-pane-btn info-pane-close';
                    closeBtn.title = 'Schließen';
                    closeBtn.innerHTML = '<svg viewBox="0 0 24 24"><path fill="currentColor" d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>';
                    closeBtn.onclick = function(e) {
                        e.stopPropagation();
                        // Falls angedockt, mapContainer zurücksetzen
                        if (isInfoPaneDocked) {
                            var mapContainer = document.getElementById('mapContainer');
                            if (mapContainer) {
                                mapContainer.style.setProperty('width', '100%', 'important');
                                setTimeout(function() {
                                    triggerMapUpdate();
                                }, 100);
                            }
                            stopMapContainerObserver();
                            isInfoPaneDocked = false;
                            infoPane.classList.remove('docked-right');
                        }
                        // Dojo FloatingPane close aufrufen
                        var widget = dijit.byId('njs_info_pane');
                        if (widget && widget.close) {
                            widget.close();
                        } else {
                            infoPane.style.visibility = 'hidden';
                        }
                    };
                    
                    actions.appendChild(clipboardBtn);
                    actions.appendChild(dockBtn);
                    actions.appendChild(closeBtn);
                    
                    // Actions ans Ende des Headers
                    titleBar.appendChild(actions);
                    
                    // Custom Resize-Handle hinzufügen
                    initInfoPaneResize(infoPane);
                    
                    return true;
                }
                
                // Initial versuchen
                enhanceInfoPane();
                
                // MutationObserver für DOM-Änderungen
                var observer = new MutationObserver(function(mutations) {
                    mutations.forEach(function(mutation) {
                        if (mutation.type === 'childList' || mutation.type === 'attributes') {
                            var infoPane = document.getElementById('njs_info_pane');
                            if (infoPane && infoPane.style.visibility !== 'hidden') {
                                enhanceInfoPane();
                                
                                // Falls angedockt, Position und Breite SOFORT wiederherstellen (verhindert Flackern)
                                if (isInfoPaneDocked && infoPane.classList.contains('docked-right')) {
                                    var savedWidth = window._savedDockedPanelWidth || 350;
                                    var streetviewContainer = document.getElementById('streetviewContainer');
                                    var centerPane = document.getElementById('centerPaneLayout');
                                    var streetviewWidth = 0;
                                    if (streetviewContainer && streetviewContainer.offsetWidth > 0 && streetviewContainer.style.display !== 'none') {
                                        streetviewWidth = streetviewContainer.offsetWidth;
                                    }
                                    
                                    infoPane.style.setProperty('width', savedWidth + 'px', 'important');
                                    infoPane.style.setProperty('right', streetviewWidth + 'px', 'important');
                                    
                                    var mapContainer = document.getElementById('mapContainer');
                                    if (mapContainer) {
                                        // Absolute Breite berechnen
                                        var centerPaneWidth = centerPane ? centerPane.offsetWidth : window.innerWidth;
                                        var mapWidth = centerPaneWidth - streetviewWidth - savedWidth;
                                        mapContainer.style.setProperty('width', mapWidth + 'px', 'important');
                                    }
                                }
                            }
                        }
                    });
                });
                
                // Beobachte body für neue Elemente
                observer.observe(document.body, {
                    childList: true,
                    subtree: true,
                    attributes: true,
                    attributeFilter: ['style', 'class']
                });
                
                // Regelmäßig prüfen (Fallback - seltener da MutationObserver jetzt Hauptarbeit macht)
                setInterval(function() {
                    var infoPane = document.getElementById('njs_info_pane');
                    if (infoPane && infoPane.style.visibility === 'visible') {
                        enhanceInfoPane();
                    }
                }, 2000);
            })();
            
            // Custom Resize für Info-Panel
            function initInfoPaneResize(pane) {
                // Bestehende Resize-Handles entfernen (falls vorhanden)
                var existingHandles = pane.querySelectorAll('[class*="info-pane-resize"]');
                existingHandles.forEach(function(h) { h.remove(); });
                
                // Alle Resize-Handles erstellen
                var handles = {
                    top: createHandle('info-pane-resize-top', 'position:absolute; top:0; left:0; right:0; height:6px; cursor:ns-resize; z-index:1000;'),
                    bottom: createHandle('info-pane-resize-bottom', 'position:absolute; bottom:0; left:0; right:0; height:6px; cursor:ns-resize; z-index:1000;'),
                    left: createHandle('info-pane-resize-left', 'position:absolute; left:0; top:0; bottom:0; width:8px; cursor:ew-resize; z-index:1000; background:linear-gradient(to right, rgba(75,123,129,0.15), transparent);'),
                    right: createHandle('info-pane-resize-right', 'position:absolute; right:0; top:0; bottom:0; width:8px; cursor:ew-resize; z-index:1000; background:linear-gradient(to left, rgba(75,123,129,0.15), transparent);'),
                    tl: createHandle('info-pane-resize-corner-tl', 'position:absolute; top:0; left:0; width:12px; height:12px; cursor:nwse-resize; z-index:1001;'),
                    tr: createHandle('info-pane-resize-corner-tr', 'position:absolute; top:0; right:0; width:12px; height:12px; cursor:nesw-resize; z-index:1001;'),
                    bl: createHandle('info-pane-resize-corner-bl', 'position:absolute; bottom:0; left:0; width:12px; height:12px; cursor:nesw-resize; z-index:1001;')
                };
                
                function createHandle(className, style) {
                    var handle = document.createElement('div');
                    handle.className = className;
                    handle.style.cssText = style;
                    pane.appendChild(handle);
                    return handle;
                }
                
                var isResizing = false;
                var resizeDirection = '';
                var startX, startY, startWidth, startHeight, startLeft, startTop;
                
                function startResize(e, direction) {
                    // Im angedockten Modus nur linken Rand erlauben
                    if (pane.classList.contains('docked-right') && direction !== 'left' && direction !== 'tl' && direction !== 'bl') return;
                    
                    isResizing = true;
                    resizeDirection = direction;
                    startX = e.clientX;
                    startY = e.clientY;
                    
                    var rect = pane.getBoundingClientRect();
                    startWidth = rect.width;
                    startHeight = rect.height;
                    startLeft = rect.left;
                    startTop = rect.top;
                    
                    document.body.style.userSelect = 'none';
                    e.preventDefault();
                    e.stopPropagation();
                }
                
                // Mousedown für alle Handles
                handles.top.onmousedown = function(e) { startResize(e, 'top'); };
                handles.bottom.onmousedown = function(e) { startResize(e, 'bottom'); };
                handles.left.onmousedown = function(e) { startResize(e, 'left'); };
                handles.right.onmousedown = function(e) { startResize(e, 'right'); };
                handles.tl.onmousedown = function(e) { startResize(e, 'tl'); };
                handles.tr.onmousedown = function(e) { startResize(e, 'tr'); };
                handles.bl.onmousedown = function(e) { startResize(e, 'bl'); };
                
                // Mousemove Handler
                var mouseMoveHandler = function(e) {
                    if (!isResizing) return;
                    
                    var dx = e.clientX - startX;
                    var dy = e.clientY - startY;
                    var newWidth = startWidth;
                    var newHeight = startHeight;
                    
                    // Angedockt: nur Breite über linken Rand ändern
                    if (pane.classList.contains('docked-right')) {
                        if (resizeDirection === 'left' || resizeDirection === 'tl' || resizeDirection === 'bl') {
                            newWidth = Math.max(300, Math.min(startWidth - dx, window.innerWidth - 100));
                            pane.style.setProperty('width', newWidth + 'px', 'important');
                            
                            // mapContainer anpassen
                            var mapContainer = document.getElementById('mapContainer');
                            if (mapContainer && isInfoPaneDocked) {
                                var actualPanelWidth = pane.offsetWidth;
                                mapContainer.style.setProperty('width', 'calc(100% - ' + actualPanelWidth + 'px)', 'important');
                            }
                        }
                        e.preventDefault();
                        return;
                    }
                    
                    // Freischwebend: alle Richtungen
                    switch(resizeDirection) {
                        case 'top':
                            newHeight = Math.max(150, startHeight - dy);
                            pane.style.setProperty('height', newHeight + 'px', 'important');
                            pane.style.setProperty('top', (startTop + dy) + 'px', 'important');
                            break;
                        case 'bottom':
                            newHeight = Math.max(150, startHeight + dy);
                            pane.style.setProperty('height', newHeight + 'px', 'important');
                            break;
                        case 'left':
                            newWidth = Math.max(350, startWidth - dx);
                            pane.style.setProperty('width', newWidth + 'px', 'important');
                            pane.style.setProperty('left', (startLeft + dx) + 'px', 'important');
                            break;
                        case 'right':
                            newWidth = Math.max(350, startWidth + dx);
                            pane.style.setProperty('width', newWidth + 'px', 'important');
                            break;
                        case 'tl':
                            newWidth = Math.max(350, startWidth - dx);
                            newHeight = Math.max(150, startHeight - dy);
                            pane.style.setProperty('width', newWidth + 'px', 'important');
                            pane.style.setProperty('height', newHeight + 'px', 'important');
                            pane.style.setProperty('left', (startLeft + dx) + 'px', 'important');
                            pane.style.setProperty('top', (startTop + dy) + 'px', 'important');
                            break;
                        case 'tr':
                            newWidth = Math.max(350, startWidth + dx);
                            newHeight = Math.max(150, startHeight - dy);
                            pane.style.setProperty('width', newWidth + 'px', 'important');
                            pane.style.setProperty('height', newHeight + 'px', 'important');
                            pane.style.setProperty('top', (startTop + dy) + 'px', 'important');
                            break;
                        case 'bl':
                            newWidth = Math.max(350, startWidth - dx);
                            newHeight = Math.max(150, startHeight + dy);
                            pane.style.setProperty('width', newWidth + 'px', 'important');
                            pane.style.setProperty('height', newHeight + 'px', 'important');
                            pane.style.setProperty('left', (startLeft + dx) + 'px', 'important');
                            break;
                        case 'br':
                            newWidth = Math.max(350, startWidth + dx);
                            newHeight = Math.max(150, startHeight + dy);
                            pane.style.setProperty('width', newWidth + 'px', 'important');
                            pane.style.setProperty('height', newHeight + 'px', 'important');
                            break;
                    }
                    e.preventDefault();
                };
                
                var mouseUpHandler = function() {
                    if (isResizing) {
                        // Nach Resize Map aktualisieren falls angedockt
                        if (pane.classList.contains('docked-right')) {
                            triggerMapUpdate();
                        }
                        isResizing = false;
                        resizeDirection = '';
                        document.body.style.cursor = '';
                        document.body.style.userSelect = '';
                    }
                };
                
                // Alte Handler entfernen falls vorhanden
                if (window._infoPaneMouseMove) {
                    document.removeEventListener('mousemove', window._infoPaneMouseMove);
                }
                if (window._infoPaneMouseUp) {
                    document.removeEventListener('mouseup', window._infoPaneMouseUp);
                }
                
                // Neue Handler speichern und registrieren
                window._infoPaneMouseMove = mouseMoveHandler;
                window._infoPaneMouseUp = mouseUpHandler;
                
                document.addEventListener('mousemove', mouseMoveHandler);
                document.addEventListener('mouseup', mouseUpHandler);
                
                // CSS-Sichtbarkeit wird über CSS gesteuert - die .docked-right Klasse verbirgt die nicht-benötigten Handles automatisch
            }
            
            // Info-Panel Inhalt in Zwischenablage kopieren
            window.copyInfoPaneToClipboard = function() {
                var content = document.getElementById('njs_info_pane_content');
                if (!content) return;
                
                // Versuche Tabellen-Daten zu extrahieren
                var tables = content.querySelectorAll('table');
                var text = '';
                
                if (tables.length > 0) {
                    tables.forEach(function(table, idx) {
                        if (idx > 0) text += '\n\n';
                        
                        // Titel falls vorhanden
                        var prevEl = table.previousElementSibling;
                        if (prevEl && (prevEl.tagName === 'H3' || prevEl.tagName === 'H4' || prevEl.className.indexOf('title') > -1)) {
                            text += prevEl.textContent.trim() + '\n';
                            text += '='.repeat(prevEl.textContent.trim().length) + '\n';
                        }
                        
                        var rows = table.querySelectorAll('tr');
                        rows.forEach(function(row) {
                            var cells = row.querySelectorAll('td, th');
                            var rowText = [];
                            cells.forEach(function(cell) {
                                rowText.push(cell.textContent.trim());
                            });
                            text += rowText.join('\t') + '\n';
                        });
                    });
                } else {
                    // Fallback: Nur Text
                    text = content.textContent.trim();
                }
                
                // In Zwischenablage kopieren
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(text).then(function() {
                        showCopyNotification('In Zwischenablage kopiert!');
                    }).catch(function(err) {
                        console.error('Clipboard Error:', err);
                        fallbackCopy(text);
                    });
                } else {
                    fallbackCopy(text);
                }
            };
            
            function fallbackCopy(text) {
                var textarea = document.createElement('textarea');
                textarea.value = text;
                textarea.style.position = 'fixed';
                textarea.style.opacity = '0';
                document.body.appendChild(textarea);
                textarea.select();
                try {
                    document.execCommand('copy');
                    showCopyNotification('In Zwischenablage kopiert!');
                } catch (err) {
                    alert('Kopieren fehlgeschlagen');
                }
                document.body.removeChild(textarea);
            }
            
            function showCopyNotification(message) {
                var notification = document.createElement('div');
                notification.textContent = message;
                notification.style.cssText = 'position:fixed;bottom:60px;left:50%;transform:translateX(-50%);background:#4b7b81;color:white;padding:10px 20px;border-radius:4px;z-index:10000;box-shadow:0 2px 8px rgba(0,0,0,0.3);';
                document.body.appendChild(notification);
                setTimeout(function() {
                    notification.style.transition = 'opacity 0.3s';
                    notification.style.opacity = '0';
                    setTimeout(function() {
                        document.body.removeChild(notification);
                    }, 300);
                }, 2000);
            }
            
            // Info-Panel andocken/abdocken
            var isInfoPaneDocked = false;
            var savedInfoPanePosition = null;
            
            // Hilfsfunktion um Map-Update zu triggern
            function triggerMapUpdate() {
                setTimeout(function() {
                    // Neapolis/OpenLayers Map
                    if (window.njs && njs.AppManager && njs.AppManager.Maps && njs.AppManager.Maps['main']) {
                        var mapObj = njs.AppManager.Maps['main'].mapObj;
                        if (mapObj && mapObj.updateSize) {
                            mapObj.updateSize();
                        }
                    }
                    // Dijit Layout Container neu berechnen
                    if (typeof dijit !== 'undefined' && dijit.byId('NeapolisContainer')) {
                        dijit.byId('NeapolisContainer').resize();
                    }
                }, 350);
            }
            
            window.toggleInfoPaneDock = function() {
                var infoPane = document.getElementById('njs_info_pane');
                var dockBtn = document.getElementById('info-pane-dock-btn');
                var mapContainer = document.getElementById('mapContainer');
                if (!infoPane) return;
                
                if (isInfoPaneDocked) {
                    // Undock - zurück zur gespeicherten Position oder Default
                    infoPane.classList.remove('docked-right');
                    
                    // Observer stoppen
                    stopMapContainerObserver();
                    
                    // mapContainer wieder auf volle Breite
                    if (mapContainer) {
                        mapContainer.style.setProperty('width', '100%', 'important');
                        setTimeout(function() {
                            triggerMapUpdate();
                        }, 100);
                    }
                    
                    if (savedInfoPanePosition) {
                        infoPane.style.setProperty('top', savedInfoPanePosition.top, 'important');
                        infoPane.style.setProperty('left', savedInfoPanePosition.left, 'important');
                        infoPane.style.setProperty('width', savedInfoPanePosition.width, 'important');
                        infoPane.style.setProperty('height', savedInfoPanePosition.height, 'important');
                    } else {
                        infoPane.style.setProperty('top', '150px', 'important');
                        infoPane.style.setProperty('left', '400px', 'important');
                        infoPane.style.setProperty('width', '720px', 'important');
                        infoPane.style.setProperty('height', '360px', 'important');
                    }
                    infoPane.style.setProperty('right', 'auto', 'important');
                    infoPane.style.setProperty('bottom', 'auto', 'important');
                    infoPane.style.setProperty('position', 'absolute', 'important');
                    infoPane.style.maxHeight = '';
                    
                    if (dockBtn) {
                        dockBtn.title = 'Rechts andocken';
                        dockBtn.innerHTML = '<svg viewBox="0 0 24 24"><path fill="currentColor" d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16h-4V5h4v14z"/></svg>';
                    }
                    isInfoPaneDocked = false;
                } else {
                    // Position speichern vor dem Andocken
                    savedInfoPanePosition = {
                        top: infoPane.style.top || '150px',
                        left: infoPane.style.left || '400px',
                        width: infoPane.style.width || '720px',
                        height: infoPane.style.height || '360px'
                    };
                    
                    // Dock - Panel rechts am centerPaneLayout, mapContainer passt sich an
                    infoPane.classList.add('docked-right');
                    
                    if (mapContainer) {
                        // Gespeicherte Breite verwenden falls vorhanden, sonst 350px
                        var panelWidth = window._savedDockedPanelWidth || 350;
                        var centerPane = document.getElementById('centerPaneLayout');
                        var streetviewContainer = document.getElementById('streetviewContainer');
                        
                        // Berechne den rechten Offset (falls StreetView offen)
                        var streetviewWidth = 0;
                        if (streetviewContainer && streetviewContainer.offsetWidth > 0 && streetviewContainer.style.display !== 'none') {
                            streetviewWidth = streetviewContainer.offsetWidth;
                        }
                        
                        // Panel am rechten Rand positionieren (neben StreetView falls offen)
                        var centerRect = centerPane ? centerPane.getBoundingClientRect() : mapContainer.getBoundingClientRect();
                        infoPane.style.setProperty('position', 'fixed', 'important');
                        infoPane.style.setProperty('top', centerRect.top + 'px', 'important');
                        infoPane.style.setProperty('right', streetviewWidth + 'px', 'important');
                        infoPane.style.setProperty('bottom', (window.innerHeight - centerRect.bottom) + 'px', 'important');
                        infoPane.style.setProperty('left', 'auto', 'important');
                        infoPane.style.setProperty('width', panelWidth + 'px', 'important');
                        infoPane.style.setProperty('height', 'auto', 'important');
                        
                        // mapContainer verkleinern: Absolute Berechnung
                        var centerPaneWidth = centerPane ? centerPane.offsetWidth : window.innerWidth;
                        var mapWidth = centerPaneWidth - streetviewWidth - panelWidth;
                        mapContainer.style.setProperty('width', mapWidth + 'px', 'important');
                        triggerMapUpdate();
                    }
                    
                    // Observer für Layout-Änderungen starten (passt Panel an wenn StreetView etc. geöffnet wird)
                    startMapContainerObserver();
                    
                    if (dockBtn) {
                        dockBtn.title = 'Floating';
                        dockBtn.innerHTML = '<svg viewBox="0 0 24 24"><path fill="currentColor" d="M19 11h-8v6h8v-6zm4 8V4.98C23 3.88 22.1 3 21 3H3c-1.1 0-2 .88-2 1.98V19c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2zm-2 .02H3V4.97h18v14.05z"/></svg>';
                    }
                    isInfoPaneDocked = true;
                }
                
                // Container-Breite bei Panel-Resize synchron halten
                updateContainerForInfoPane();
            };
            
            // Observer für Layout-Änderungen (z.B. wenn StreetView geöffnet wird)
            var mapContainerObserver = null;
            var streetviewObserver = null;
            function startMapContainerObserver() {
                if (mapContainerObserver) mapContainerObserver.disconnect();
                if (streetviewObserver) streetviewObserver.disconnect();
                
                var mapContainer = document.getElementById('mapContainer');
                var streetviewContainer = document.getElementById('streetviewContainer');
                var infoPane = document.getElementById('njs_info_pane');
                if (!mapContainer || !infoPane) return;
                
                // ResizeObserver für Größenänderungen des mapContainer
                if (window.ResizeObserver) {
                    mapContainerObserver = new ResizeObserver(function() {
                        if (!isInfoPaneDocked) return;
                        updateDockedInfoPanePosition();
                    });
                    mapContainerObserver.observe(mapContainer);
                    
                    // Auch streetviewContainer beobachten
                    if (streetviewContainer) {
                        streetviewObserver = new ResizeObserver(function() {
                            if (!isInfoPaneDocked) return;
                            updateDockedInfoPanePosition();
                        });
                        streetviewObserver.observe(streetviewContainer);
                    }
                }
                
                // Auch auf Window-Resize reagieren
                window.addEventListener('resize', updateDockedInfoPanePosition);
            }
            
            function stopMapContainerObserver() {
                if (mapContainerObserver) {
                    mapContainerObserver.disconnect();
                    mapContainerObserver = null;
                }
                if (streetviewObserver) {
                    streetviewObserver.disconnect();
                    streetviewObserver = null;
                }
                window.removeEventListener('resize', updateDockedInfoPanePosition);
            }
            
            // geo.admin.ch REST API Abfrage
            function queryGeoAdminLayer(layer, polygonCoords) {
                return new Promise(function(resolve, reject) {
                    console.log('geo.admin.ch REST API Query für:', layer.name, layer.wmsLayers);
                    
                    // Layer-Name anpassen: ÖREB-Layer haben _v2_0.oereb Suffix, das muss entfernt werden
                    // Beispiel: ch.astra.baulinien-nationalstrassen_v2_0.oereb → ch.astra.baulinien-nationalstrassen
                    var layerName = layer.wmsLayers;
                    if (layerName) {
                        // Entferne .oereb Suffix
                        if (layerName.endsWith('.oereb')) {
                            layerName = layerName.substring(0, layerName.length - 6);
                            console.log('Nach Entfernung von .oereb:', layerName);
                        }
                        // Entferne _vX_Y Versions-Suffix (z.B. _v2_0, _v1_0)
                        layerName = layerName.replace(/_v\d+_\d+$/, '');
                        console.log('ÖREB Layer-Name für API:', layerName);
                    }
                    
                    // Polygon zu ESRI JSON Format konvertieren
                    var rings = [polygonCoords.map(function(coord) {
                        return [Math.round(coord[0]), Math.round(coord[1])];
                    })];
                    
                    var geometryJson = {
                        rings: rings,
                        spatialReference: { wkid: 2056 }
                    };
                    
                    // API-Endpunkt
                    var apiUrl = 'https://api3.geo.admin.ch/rest/services/api/MapServer/identify';
                    
                    // Sprache fix auf Deutsch
                    var lang = 'de';
                    console.log('API Sprache:', lang);
                    
                    // Parameter
                    var params = new URLSearchParams({
                        geometry: JSON.stringify(geometryJson),
                        geometryType: 'esriGeometryPolygon',
                        layers: 'all:' + layerName, // Layer-Name (ohne _vX_Y.oereb)
                        tolerance: '0',
                        mapExtent: '0,0,0,0',
                        imageDisplay: '0,0,0',
                        sr: '2056',
                        returnGeometry: 'true',
                        geometryFormat: 'geojson',
                        lang: lang
                    });
                    
                    var queryUrl = apiUrl + '?' + params.toString();
                    console.log('geo.admin.ch API URL:', queryUrl);
                    
                    fetch(queryUrl)
                        .then(function(response) { return response.json(); })
                        .then(function(data) {
                            console.log('geo.admin.ch Response:', data);
                            
                            var features = [];
                            if (data.results && data.results.length > 0) {
                                features = data.results.map(function(result) {
                                    var attrs = result.attributes || result.properties || {};
                                    
                                    // Datumsfelder formatieren (z.B. 2019-07-30T00:00:00 → 30.07.2019)
                                    Object.keys(attrs).forEach(function(key) {
                                        var value = attrs[key];
                                        // Prüfe ob es ein ISO-Datum ist (YYYY-MM-DDTHH:mm:ss oder YYYY-MM-DD)
                                        if (typeof value === 'string' && /^\d{4}-\d{2}-\d{2}(T\d{2}:\d{2}:\d{2})?/.test(value)) {
                                            try {
                                                var date = new Date(value);
                                                if (!isNaN(date.getTime())) {
                                                    // Formatiere als DD.MM.YYYY
                                                    var day = ('0' + date.getDate()).slice(-2);
                                                    var month = ('0' + (date.getMonth() + 1)).slice(-2);
                                                    var year = date.getFullYear();
                                                    attrs[key] = day + '.' + month + '.' + year;
                                                }
                                            } catch(e) {
                                                // Bei Fehler Original-Wert behalten
                                            }
                                        }
                                    });
                                    
                                    return {
                                        attributes: attrs,
                                        geometry: result.geometry || null
                                    };
                                });
                            }
                            
                            console.log('geo.admin.ch Features:', features.length);
                            
                            // Besseren Layer-Namen verwenden (wmsLayers statt layer.name)
                            var displayName = layer.wmsLayers || layer.name || 'Unbekannter Layer';
                            // Entferne .oereb und _vX_Y Suffixe für Anzeige
                            displayName = displayName.replace(/_v\d+_\d+(\.oereb)?$/, '');
                            displayName = displayName.replace(/\.oereb$/, '');
                            
                            resolve({
                                layerName: displayName + ' (geo.admin.ch)',
                                features: features,
                                error: null
                            });
                        })
                        .catch(function(err) {
                            console.error('geo.admin.ch API Fehler:', err);
                            
                            var displayName = layer.wmsLayers || layer.name || 'Unbekannter Layer';
                            displayName = displayName.replace(/_v\d+_\d+(\.oereb)?$/, '');
                            displayName = displayName.replace(/\.oereb$/, '');
                            
                            resolve({
                                layerName: displayName + ' (geo.admin.ch)',
                                features: [],
                                error: 'API-Fehler: ' + err.message
                            });
                        });
                });
            }
            
            function updateDockedInfoPanePosition() {
                if (!isInfoPaneDocked) return;
                var mapContainer = document.getElementById('mapContainer');
                var infoPane = document.getElementById('njs_info_pane');
                var centerPane = document.getElementById('centerPaneLayout');
                var streetviewContainer = document.getElementById('streetviewContainer');
                if (!mapContainer || !infoPane) return;
                
                var panelWidth = window._savedDockedPanelWidth || infoPane.offsetWidth || 350;
                
                // Berechne den rechten Offset (falls StreetView offen)
                var streetviewWidth = 0;
                if (streetviewContainer && streetviewContainer.offsetWidth > 0 && streetviewContainer.style.display !== 'none') {
                    streetviewWidth = streetviewContainer.offsetWidth;
                }
                
                // Panel-Position aktualisieren - rechts neben StreetView
                var centerRect = centerPane ? centerPane.getBoundingClientRect() : { top: 69, bottom: window.innerHeight - 32 };
                infoPane.style.setProperty('top', centerRect.top + 'px', 'important');
                infoPane.style.setProperty('right', streetviewWidth + 'px', 'important');
                infoPane.style.setProperty('bottom', (window.innerHeight - centerRect.bottom) + 'px', 'important');
                infoPane.style.setProperty('width', panelWidth + 'px', 'important');
                
                // mapContainer-Breite: Absolute Berechnung
                // Verfügbare Breite = centerPaneLayout.width - streetviewWidth - panelWidth
                var centerPaneWidth = centerPane ? centerPane.offsetWidth : window.innerWidth;
                var mapWidth = centerPaneWidth - streetviewWidth - panelWidth;
                mapContainer.style.setProperty('width', mapWidth + 'px', 'important');
                
                triggerMapUpdate();
            }
            
            // Funktion um Panel-Position bei Resize zu aktualisieren (ohne Container zu ändern)
            function updateContainerForInfoPane() {
                // Nichts zu tun - mapContainer wird nicht mehr verändert
                // Panel passt sich automatisch über updateDockedInfoPanePosition an
            }
            
            // Räumliche Abfrage gegen ArcGIS Server
            function executeSpatialQuery(polygonCoords) {
                var statusEl = document.getElementById('spatial-query-status');
                var resultsEl = document.getElementById('spatial-query-results');
                
                // Aktive Layer aus dem Layer-Manager holen
                var visibleLayers = getVisibleQueryableLayers();
                
                console.log('=== SPATIAL QUERY DEBUG ===');
                console.log('Gefundene Layer:', visibleLayers);
                console.log('Polygon Koordinaten:', polygonCoords);
                
                if (visibleLayers.length === 0) {
                    statusEl.textContent = 'Keine abfragbaren Layer aktiv.';
                    resultsEl.innerHTML = '<p class="no-results">Aktivieren Sie Layer im Layer-Manager, die abgefragt werden können.</p>';
                    return;
                }
                
                // Polygon-BBOX berechnen für WMS GetFeatureInfo
                var minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                polygonCoords.forEach(function(coord) {
                    if (coord[0] < minX) minX = coord[0];
                    if (coord[1] < minY) minY = coord[1];
                    if (coord[0] > maxX) maxX = coord[0];
                    if (coord[1] > maxY) maxY = coord[1];
                });
                var polygonBbox = [minX, minY, maxX, maxY];
                var polygonCenter = [(minX + maxX) / 2, (minY + maxY) / 2];
                
                // Polygon zu ArcGIS JSON Format konvertieren
                var rings = [polygonCoords.map(function(coord) {
                    return [Math.round(coord[0]), Math.round(coord[1])];
                })];
                
                var geometryJson = JSON.stringify({
                    rings: rings,
                    spatialReference: { wkid: 2056 }
                });
                
                console.log('Geometry JSON:', geometryJson);
                console.log('Polygon BBOX:', polygonBbox);
                
                statusEl.textContent = 'Abfrage von ' + visibleLayers.length + ' Layer(n)...';
                
                var promises = visibleLayers.map(function(layer) {
                    if (layer.type === 'wms') {
                        return queryWfsLayer(layer, polygonBbox, polygonCoords);
                    } else {
                        return querySingleLayer(layer, geometryJson);
                    }
                });
                
                Promise.all(promises).then(function(results) {
                    console.log('Query Results:', results);
                    displayResults(results, visibleLayers);
                }).catch(function(err) {
                    console.error('Spatial Query Error:', err);
                    statusEl.textContent = 'Fehler bei der Abfrage.';
                    resultsEl.innerHTML = '<p class="error">' + err.message + '</p>';
                });
            }
            
            // WFS/API Layer abfragen (echte räumliche Abfrage mit Polygon)
            // HINWEIS: Bei MapServer kann der WFS TYPENAME vom WMS LAYERS abweichen
            function queryWfsLayer(layer, bbox, polygonCoords) {
                return new Promise(function(resolve, reject) {
                    console.log('Query für Layer:', layer.name, layer.url, layer.mapParam);
                    
                    // geo.admin.ch / Schweizer Bundesdienste: Verwende REST API statt WFS
                    // Erkennung: URL enthält geo.admin.ch ODER Layer-Name beginnt mit "ch."
                    var isGeoAdmin = (layer.url && layer.url.indexOf('geo.admin.ch') > -1) ||
                                     (layer.wmsLayers && layer.wmsLayers.indexOf('ch.') === 0);
                    
                    if (isGeoAdmin) {
                        console.log('Schweizer Bundeslayer erkannt (geo.admin.ch), verwende REST API');
                        return queryGeoAdminLayer(layer, polygonCoords).then(resolve).catch(reject);
                    }
                    
                    // WFS URL aus WMS URL ableiten
                    var wfsUrl = layer.url;
                    
                    // MapServer: map Parameter (direkt aus Layer-Objekt)
                    var mapParam = layer.mapParam || '';
                    
                    // Fallback: Versuche aus sourceParams oder URL zu extrahieren
                    if (!mapParam && layer.sourceParams) {
                        mapParam = layer.sourceParams.map || layer.sourceParams.MAP || '';
                    }
                    if (!mapParam && layer.url) {
                        var urlMatch = layer.url.match(/[?&]map=([^&]+)/i);
                        if (urlMatch) {
                            mapParam = decodeURIComponent(urlMatch[1]);
                        }
                    }
                    
                    console.log('MapServer map Parameter:', mapParam);
                    
                    // Funktion um WFS GetFeature auszuführen
                    function executeWfsQuery(typeName) {
                        var params = new URLSearchParams({
                            SERVICE: 'WFS',
                            VERSION: '2.0.0',
                            REQUEST: 'GetFeature',
                            TYPENAMES: typeName,  // WFS 2.0 nutzt TYPENAMES (Plural)
                            BBOX: bbox.join(',') + ',EPSG:2056',  // WFS 2.0: BBOX enthält CRS
                            COUNT: '1000'  // WFS 2.0 nutzt COUNT statt MAXFEATURES
                        });
                        
                        if (mapParam) {
                            params.set('map', mapParam);
                        }
                        
                        var queryUrl = wfsUrl + '?' + params.toString();
                        console.log('WFS 2.0 Query URL (BBOX):', queryUrl);
                        console.log('  TYPENAMES:', typeName);
                        console.log('  BBOX:', bbox.join(',') + ',EPSG:2056');
                        
                        return fetch(queryUrl).then(function(response) {
                            return response.text();
                        });
                    }
                    
                    // Zuerst: Versuche mit WMS Layer-Name
                    var wmsLayerName = layer.wmsLayers;
                    
                    // Spezialfall: Liegenschaften-Layer (av_ls_eigentuemer.map)
                    // Dieser enthält mehrere Kantone - abfrage direkt via GetCapabilities alle
                    var isLiegenschaftenLayer = mapParam && mapParam.indexOf('av_ls_eigentuemer') > -1;
                    
                    if (isLiegenschaftenLayer) {
                        console.log('Liegenschaften-Layer erkannt (av_ls_eigentuemer.map), lade GetCapabilities für Multi-Kanton-Abfrage...');
                        
                        var capParams = new URLSearchParams({
                            SERVICE: 'WFS',
                            VERSION: '2.0.0',
                            REQUEST: 'GetCapabilities'
                        });
                        if (mapParam) capParams.set('map', mapParam);
                        
                        fetch(wfsUrl + '?' + capParams.toString())
                            .then(function(r) { return r.text(); })
                            .then(function(capText) {
                                console.log('GetCapabilities Response (first 1000):', capText.substring(0, 1000));
                                var parser = new DOMParser();
                                var capXml = parser.parseFromString(capText, 'text/xml');
                                var featureTypes = capXml.querySelectorAll('FeatureType Name, FeatureType > Name');
                                console.log('FeatureType Elements gefunden:', featureTypes.length);
                                var allTypes = Array.from(featureTypes).map(function(ft) { return ft.textContent.trim(); });
                                console.log('Alle FeatureTypes:', allTypes);
                                
                                var liegenschaftenTypes = allTypes.filter(function(t) {
                                    return t.indexOf('liegenschaften_') > -1;
                                });
                                
                                // Sortiere NW vor OW (für Test)
                                liegenschaftenTypes.sort(function(a, b) {
                                    if (a.indexOf('_nw') > -1) return -1;
                                    if (b.indexOf('_nw') > -1) return 1;
                                    return 0;
                                });
                                
                                console.log('Liegenschaften-Kantone (NW zuerst):', liegenschaftenTypes.join(', '));
                                
                                // Abfrage alle Kantone parallel
                                var queries = liegenschaftenTypes.map(function(typeName) {
                                    console.log('Starte WFS Query für:', typeName);
                                    return executeWfsQuery(typeName)
                                        .then(function(response) {
                                            console.log('Response für ' + typeName + ':', response ? response.substring(0, 200) : 'null');
                                            if (response && response.indexOf('FeatureCollection') > -1) {
                                                var parsed = parseWfsGmlResponse(response, typeName, polygonCoords);
                                                console.log('Geparste Features für ' + typeName + ':', parsed.features ? parsed.features.length : 0);
                                                return { typeName: typeName, data: parsed };
                                            }
                                            console.log('Keine FeatureCollection für ' + typeName);
                                            return { typeName: typeName, data: { features: [] } };
                                        })
                                        .catch(function(err) {
                                            console.error('WFS Query für ' + typeName + ' fehlgeschlagen:', err);
                                            return { typeName: typeName, data: { features: [] } };
                                        });
                                });
                                
                                return Promise.all(queries);
                            })
                            .then(function(results) {
                                // Kombiniere alle Features
                                var allFeatures = [];
                                results.forEach(function(result) {
                                    if (result.data && result.data.features && result.data.features.length > 0) {
                                        console.log('Features von ' + result.typeName + ':', result.data.features.length);
                                        // Konvertiere Features in das erwartete Format
                                        result.data.features.forEach(function(f) {
                                            allFeatures.push({
                                                attributes: f.properties || f.attributes || {},
                                                geometry: f.geometry || null
                                            });
                                        });
                                    }
                                });
                                
                                console.log('Gesamt Features aus allen Kantonen:', allFeatures.length);
                                
                                resolve({
                                    layerName: layer.name + ' (WFS Multi-Kanton)',
                                    features: allFeatures,
                                    error: null
                                });
                            })
                            .catch(function(err) {
                                console.error('Multi-Kanton WFS Fehler:', err);
                                resolve({
                                    layerName: layer.name + ' (WFS)',
                                    features: [],
                                    error: 'Multi-Kanton WFS Fehler: ' + err.message
                                });
                            });
                        
                        return; // Beende Funktion hier für Liegenschaften
                    }
                    
                    // Normaler Single-Layer WFS Query
                    executeWfsQuery(wmsLayerName)
                        .then(function(text) {
                            // Prüfe auf "TYPENAME doesn't exist" Fehler
                            if (text.indexOf("doesn't exist") > -1 || text.indexOf('does not exist') > -1) {
                                console.log('TYPENAME "' + wmsLayerName + '" nicht gefunden, lade GetCapabilities...');
                                // GetCapabilities abrufen um verfügbare Layer zu finden
                                var capParams = new URLSearchParams({
                                    SERVICE: 'WFS',
                                    VERSION: '2.0.0',
                                    REQUEST: 'GetCapabilities'
                                });
                                if (mapParam) capParams.set('map', mapParam);
                                
                                return fetch(wfsUrl + '?' + capParams.toString())
                                    .then(function(r) { return r.text(); })
                                    .then(function(capText) {
                                        // Parse XML und finde FeatureType Names
                                        var parser = new DOMParser();
                                        var capXml = parser.parseFromString(capText, 'text/xml');
                                        var featureTypes = capXml.querySelectorAll('FeatureType Name, FeatureType > Name');
                                        
                                        if (featureTypes.length > 0) {
                                            var allTypes = Array.from(featureTypes).map(function(ft) { return ft.textContent.trim(); });
                                            console.log('Verfügbare FeatureTypes:', allTypes.join(', '));
                                            
                                            // Suche nach passenden FeatureType basierend auf WMS Layer-Name
                                            var matchingType = null;
                                            
                                            // 1. Versuch: Exakte Übereinstimmung
                                            matchingType = allTypes.find(function(t) { return t === wmsLayerName; });
                                            
                                            // 2. Versuch: WMS Layer-Name enthält FeatureType
                                            if (!matchingType) {
                                                matchingType = allTypes.find(function(t) { 
                                                    return wmsLayerName.toLowerCase().indexOf(t.toLowerCase()) > -1; 
                                                });
                                            }
                                            
                                            // 3. Versuch: FeatureType enthält WMS Layer-Name
                                            if (!matchingType) {
                                                matchingType = allTypes.find(function(t) { 
                                                    return t.toLowerCase().indexOf(wmsLayerName.toLowerCase()) > -1; 
                                                });
                                            }
                                            
                                            // 4. Versuch: Suche nach Kanton-Kürzel (nw, ow, etc.) im WMS-Namen
                                            if (!matchingType) {
                                                var kantonMatch = wmsLayerName.match(/_(nw|ow|ur|sz|gl|zg|be|lu|ag|zh|so|bs|bl|sh|sg|ai|ar|ti|tg|vs|ge|fr|ne|ju|vd)_/i);
                                                if (kantonMatch) {
                                                    var kanton = kantonMatch[1].toLowerCase();
                                                    matchingType = allTypes.find(function(t) { 
                                                        return t.toLowerCase().indexOf('_' + kanton) > -1 || t.toLowerCase().endsWith('_' + kanton);
                                                    });
                                                    console.log('Suche nach Kanton "' + kanton + '" in FeatureTypes...');
                                                }
                                            }
                                            
                                            // Fallback: erster FeatureType
                                            if (!matchingType) {
                                                matchingType = allTypes[0];
                                                console.warn('Kein passender FeatureType gefunden, verwende ersten:', matchingType);
                                            } else {
                                                console.log('Passender FeatureType gefunden:', matchingType);
                                            }
                                            
                                            return executeWfsQuery(matchingType);
                                        }
                                        return text; // Gib Original-Fehler zurück
                                    });
                            }
                            return text;
                        })
                        .then(function(textOrData) {
                            // Spezialfall: Kombinierte Daten (von Multi-Kanton-Abfrage)
                            if (textOrData && textOrData._combined) {
                                console.log('Kombinierte Multi-Kanton-Daten erhalten:', textOrData.features.length, 'Features');
                                return textOrData; // Bereits geparste Daten
                            }
                            
                            var text = textOrData;
                            
                            // Prüfe auf WFS Exception oder Fehler
                            if (text.indexOf('ExceptionReport') > -1 || text.indexOf('Exception') > -1) {
                                console.warn('WFS Exception oder Fehler:', text.substring(0, 500));
                                // WFS nicht verfügbar - leere Ergebnisse zurückgeben
                                return { features: [], error: 'WFS nicht verfügbar oder Layer nicht gefunden' };
                            }
                            
                            // GML Response parsen
                            return parseWfsGmlResponse(text, layer.wmsLayers, polygonCoords);
                        })
                        .then(function(data) {
                            var features = [];
                            
                            if (data && data.features) {
                                // Features aus GML/GeoJSON
                                data.features.forEach(function(f) {
                                    var geom = f.geometry;
                                    var attrs = f.properties || f.attributes || {};
                                    
                                    // WFS 2.0 mit BBOX filtert bereits serverseitig
                                    // Nur noch prüfen ob Geometrie vorhanden, nicht mehr punktgenau filtern
                                    // (die BBOX-Abfrage ist bereits räumlich korrekt)
                                    features.push({
                                        attributes: attrs,
                                        geometry: geom || null
                                    });
                                });
                            }
                            
                            console.log('WFS Features nach BBOX-Filterung:', features.length);
                            resolve({
                                layerName: layer.name + ' (WFS)',
                                features: features,
                                error: null
                            });
                        })
                        .catch(function(err) {
                            console.error('WFS Query Error:', err);
                            resolve({
                                layerName: layer.name + ' (WFS)',
                                features: [],
                                error: err.message
                            });
                        });
                });
            }
            
            // Prüfe ob eine Geometrie das Polygon schneidet
            function isGeometryInPolygon(geom, polygonCoords) {
                if (!geom) return false;
                
                // Punkt in Polygon prüfen
                function pointInPolygon(x, y, polygon) {
                    var inside = false;
                    for (var i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                        var xi = polygon[i][0], yi = polygon[i][1];
                        var xj = polygon[j][0], yj = polygon[j][1];
                        if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
                            inside = !inside;
                        }
                    }
                    return inside;
                }
                
                if (geom.type === 'Point') {
                    return pointInPolygon(geom.coordinates[0], geom.coordinates[1], polygonCoords);
                } else if (geom.type === 'MultiPoint') {
                    return geom.coordinates.some(function(c) {
                        return pointInPolygon(c[0], c[1], polygonCoords);
                    });
                } else if (geom.type === 'LineString') {
                    return geom.coordinates.some(function(c) {
                        return pointInPolygon(c[0], c[1], polygonCoords);
                    });
                } else if (geom.type === 'Polygon' || geom.type === 'MultiPolygon') {
                    // Für Polygone: Prüfe ob ein Punkt im Suchpolygon liegt
                    var coords = geom.type === 'Polygon' ? geom.coordinates[0] : geom.coordinates[0][0];
                    return coords.some(function(c) {
                        return pointInPolygon(c[0], c[1], polygonCoords);
                    });
                }
                
                return true; // Im Zweifelsfall akzeptieren
            }
            
            // Parse WFS GML Response (MapServer GML3)
            function parseWfsGmlResponse(text, layerName, polygonCoords) {
                var features = [];
                
                console.log('Parsing WFS Response, length:', text.length);
                console.log('WFS Response (first 500):', text.substring(0, 500));
                
                // Versuche als JSON zu parsen (falls doch JSON)
                try {
                    var json = JSON.parse(text);
                    return json;
                } catch (e) {}
                
                // Prüfe auf Exception
                if (text.indexOf('ExceptionReport') > -1 || text.indexOf('Exception') > -1) {
                    console.error('WFS Exception:', text);
                    return { features: [], error: text };
                }
                
                // Prüfe auf leere FeatureCollection
                if (text.indexOf('numberReturned="0"') > -1 || 
                    (text.indexOf('FeatureCollection') > -1 && text.indexOf('member>') === -1 && text.indexOf('featureMember>') === -1)) {
                    console.log('Leere FeatureCollection');
                    return { features: [] };
                }
                
                // GML/XML parsen
                try {
                    var parser = new DOMParser();
                    var xml = parser.parseFromString(text, 'text/xml');
                    
                    // Debug: Log XML structure
                    console.log('XML Root:', xml.documentElement ? xml.documentElement.tagName : 'null');
                    
                    // WFS 2.0: wfs:member
                    var members = xml.getElementsByTagNameNS('http://www.opengis.net/wfs/2.0', 'member');
                    
                    // WFS 1.1/1.0: gml:featureMember
                    if (members.length === 0) {
                        members = xml.getElementsByTagNameNS('http://www.opengis.net/gml/3.2', 'featureMember');
                    }
                    if (members.length === 0) {
                        members = xml.getElementsByTagNameNS('http://www.opengis.net/gml', 'featureMember');
                    }
                    
                    // Fallback ohne Namespace
                    if (members.length === 0) {
                        members = xml.querySelectorAll('member, featureMember');
                    }
                    
                    // MapServer-spezifisch: Suche nach Layer-Namen als Element
                    if (members.length === 0 && layerName) {
                        // Versuche mit ms: Namespace
                        var layerElements = xml.getElementsByTagNameNS('http://mapserver.gis.umn.edu/mapserver', layerName);
                        if (layerElements.length === 0) {
                            layerElements = xml.getElementsByTagName(layerName);
                        }
                        if (layerElements.length === 0) {
                            layerElements = xml.getElementsByTagName('ms:' + layerName);
                        }
                        if (layerElements.length > 0) {
                            members = Array.from(layerElements).map(function(el) {
                                return { firstElementChild: el, children: [el] };
                            });
                        }
                    }
                    
                    console.log('Found', members.length, 'feature members');
                    
                    Array.from(members).forEach(function(member) {
                        var feature = { properties: {}, geometry: null };
                        
                        // Extrahiere alle Kind-Elemente als Properties
                        var featureElement = member.firstElementChild || member;
                        if (featureElement) {
                            Array.from(featureElement.children || featureElement.childNodes).forEach(function(child) {
                                if (child.nodeType !== 1) return; // Nur Element-Nodes
                                
                                var tagName = child.localName || child.tagName;
                                // Entferne Namespace-Präfix
                                if (tagName.indexOf(':') > -1) {
                                    tagName = tagName.split(':')[1];
                                }
                                
                                // Geometrie-Elemente speziell behandeln für Highlighting
                                if (tagName === 'geom_gml' || tagName === 'msGeometry' || 
                                    tagName === 'geometry' || tagName === 'geom' || tagName === 'the_geom' ||
                                    tagName === 'shape' || tagName === 'wkb_geometry') {
                                    // Versuche GML-Geometrie zu parsen
                                    var gmlGeom = parseGmlGeometry(child);
                                    if (gmlGeom) {
                                        feature.geometry = gmlGeom;
                                    }
                                    return;
                                }
                                
                                // Überspringe Geometrie-Container
                                if (tagName === 'boundedBy' || tagName === 'Envelope') {
                                    return;
                                }
                                
                                // Extrahiere Text-Inhalt
                                var value = child.textContent || '';
                                if (value.trim()) {
                                    feature.properties[tagName] = value.trim();
                                }
                            });
                        }
                        
                        if (Object.keys(feature.properties).length > 0) {
                            features.push(feature);
                        }
                    });
                    
                    console.log('Parsed', features.length, 'features from GML');
                    
                } catch (e) {
                    console.warn('GML Parse Error:', e);
                }
                
                return { features: features };
            }
            
            // GML Geometrie zu GeoJSON parsen
            function parseGmlGeometry(gmlElement) {
                try {
                    // GML Namespaces (3.2 und 3.1)
                    var gmlNs32 = 'http://www.opengis.net/gml/3.2';
                    var gmlNs31 = 'http://www.opengis.net/gml';
                    
                    // Finde das eigentliche Geometrie-Element (verschiedene Namespaces)
                    var geomTypes = ['Point', 'MultiPoint', 'LineString', 'MultiLineString', 'Polygon', 'MultiPolygon', 'MultiSurface', 'MultiCurve'];
                    var geomEl = null;
                    
                    for (var i = 0; i < geomTypes.length && !geomEl; i++) {
                        geomEl = gmlElement.getElementsByTagNameNS(gmlNs32, geomTypes[i])[0] ||
                                 gmlElement.getElementsByTagNameNS(gmlNs31, geomTypes[i])[0];
                    }
                    
                    // Fallback ohne Namespace
                    if (!geomEl) {
                        geomEl = gmlElement.querySelector('Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon, MultiSurface, MultiCurve');
                    }
                    
                    if (!geomEl) return null;
                    
                    var geomType = (geomEl.localName || geomEl.tagName).replace(/^gml:/, '');
                    
                    if (geomType === 'Point') {
                        var coords = extractGmlCoords(geomEl);
                        if (coords.length >= 1) {
                            return { type: 'Point', coordinates: coords[0] };
                        }
                    } else if (geomType === 'MultiPoint') {
                        var coords = extractGmlCoords(geomEl);
                        return { type: 'MultiPoint', coordinates: coords };
                    } else if (geomType === 'LineString') {
                        var coords = extractGmlCoords(geomEl);
                        return { type: 'LineString', coordinates: coords };
                    } else if (geomType === 'Polygon') {
                        var coords = extractGmlPolygonCoords(geomEl);
                        if (coords.length > 0) {
                            return { type: 'Polygon', coordinates: coords };
                        }
                    } else if (geomType === 'MultiPolygon' || geomType === 'MultiSurface') {
                        // MultiSurface wird wie MultiPolygon behandelt
                        var coords = extractGmlMultiPolygonCoords(geomEl);
                        if (coords.length === 1) {
                            // Nur ein Polygon - vereinfachen
                            return { type: 'Polygon', coordinates: coords[0] };
                        }
                        return { type: 'MultiPolygon', coordinates: coords };
                    }
                } catch (e) {
                    console.warn('GML Geometry Parse Error:', e);
                }
                return null;
            }
            
            // GML Koordinaten extrahieren
            function extractGmlCoords(element) {
                var coords = [];
                var gmlNs32 = 'http://www.opengis.net/gml/3.2';
                var gmlNs31 = 'http://www.opengis.net/gml';
                
                // Versuche pos oder posList (GML 3.x)
                var posList = element.getElementsByTagNameNS(gmlNs32, 'posList')[0] ||
                              element.getElementsByTagNameNS(gmlNs31, 'posList')[0] ||
                              element.querySelector('posList');
                if (posList) {
                    var values = posList.textContent.trim().split(/\s+/);
                    var dim = parseInt(posList.getAttribute('srsDimension')) || 2;
                    for (var i = 0; i < values.length - (dim - 1); i += dim) {
                        coords.push([parseFloat(values[i]), parseFloat(values[i + 1])]);
                    }
                    return coords;
                }
                
                // Versuche pos (einzelner Punkt)
                var pos = element.getElementsByTagNameNS(gmlNs32, 'pos')[0] ||
                          element.getElementsByTagNameNS(gmlNs31, 'pos')[0] ||
                          element.querySelector('pos');
                if (pos) {
                    var values = pos.textContent.trim().split(/\s+/);
                    coords.push([parseFloat(values[0]), parseFloat(values[1])]);
                    return coords;
                }
                
                // Versuche coordinates (GML 2)
                var coordinates = element.querySelector('coordinates');
                if (coordinates) {
                    var pairs = coordinates.textContent.trim().split(/\s+/);
                    pairs.forEach(function(pair) {
                        var xy = pair.split(',');
                        if (xy.length >= 2) {
                            coords.push([parseFloat(xy[0]), parseFloat(xy[1])]);
                        }
                    });
                }
                
                return coords;
            }
            
            // GML Polygon Koordinaten extrahieren
            function extractGmlPolygonCoords(element) {
                var rings = [];
                var gmlNs32 = 'http://www.opengis.net/gml/3.2';
                var gmlNs31 = 'http://www.opengis.net/gml';
                
                // Exterior Ring
                var exterior = element.getElementsByTagNameNS(gmlNs32, 'exterior')[0] ||
                               element.getElementsByTagNameNS(gmlNs31, 'exterior')[0] ||
                               element.querySelector('exterior, outerBoundaryIs');
                if (exterior) {
                    var linearRing = exterior.getElementsByTagNameNS(gmlNs32, 'LinearRing')[0] ||
                                     exterior.getElementsByTagNameNS(gmlNs31, 'LinearRing')[0] ||
                                     exterior.querySelector('LinearRing');
                    if (linearRing) {
                        rings.push(extractGmlCoords(linearRing));
                    }
                }
                
                // Interior Rings (Löcher)
                var interiors = element.getElementsByTagNameNS(gmlNs32, 'interior');
                if (interiors.length === 0) {
                    interiors = element.getElementsByTagNameNS(gmlNs31, 'interior');
                }
                if (interiors.length === 0) {
                    interiors = element.querySelectorAll('interior, innerBoundaryIs');
                }
                Array.from(interiors).forEach(function(interior) {
                    var linearRing = interior.getElementsByTagNameNS(gmlNs32, 'LinearRing')[0] ||
                                     interior.getElementsByTagNameNS(gmlNs31, 'LinearRing')[0] ||
                                     interior.querySelector('LinearRing');
                    if (linearRing) {
                        rings.push(extractGmlCoords(linearRing));
                    }
                });
                
                return rings;
            }
            
            // GML MultiPolygon Koordinaten extrahieren
            function extractGmlMultiPolygonCoords(element) {
                var polygons = [];
                var gmlNs32 = 'http://www.opengis.net/gml/3.2';
                var gmlNs31 = 'http://www.opengis.net/gml';
                
                // Suche nach verschiedenen Member-Typen
                var members = element.getElementsByTagNameNS(gmlNs32, 'surfaceMember');
                if (members.length === 0) {
                    members = element.getElementsByTagNameNS(gmlNs31, 'surfaceMember');
                }
                if (members.length === 0) {
                    members = element.getElementsByTagNameNS(gmlNs32, 'polygonMember');
                }
                if (members.length === 0) {
                    members = element.getElementsByTagNameNS(gmlNs31, 'polygonMember');
                }
                if (members.length === 0) {
                    members = element.querySelectorAll('polygonMember, surfaceMember');
                }
                
                Array.from(members).forEach(function(member) {
                    var polygon = member.getElementsByTagNameNS(gmlNs32, 'Polygon')[0] ||
                                  member.getElementsByTagNameNS(gmlNs31, 'Polygon')[0] ||
                                  member.querySelector('Polygon');
                    if (polygon) {
                        var polyCoords = extractGmlPolygonCoords(polygon);
                        if (polyCoords.length > 0) {
                            polygons.push(polyCoords);
                        }
                    }
                });
                
                // Falls keine Members gefunden, versuche direkt Polygone zu finden
                if (polygons.length === 0) {
                    var directPolygons = element.getElementsByTagNameNS(gmlNs32, 'Polygon');
                    if (directPolygons.length === 0) {
                        directPolygons = element.getElementsByTagNameNS(gmlNs31, 'Polygon');
                    }
                    if (directPolygons.length === 0) {
                        directPolygons = element.querySelectorAll('Polygon');
                    }
                    Array.from(directPolygons).forEach(function(polygon) {
                        var polyCoords = extractGmlPolygonCoords(polygon);
                        if (polyCoords.length > 0) {
                            polygons.push(polyCoords);
                        }
                    });
                }
                
                return polygons;
            }
            
            // Einzelnen ArcGIS Layer abfragen
            function querySingleLayer(layer, geometryJson) {
                return new Promise(function(resolve, reject) {
                    // Die layer.url kann verschiedene Formate haben:
                    // 1. Proxy-URL: /maps/agsproxy.php/gis_oereb/service/MapServer/0
                    // 2. Direkte URL: https://server/arcgis/rest/services/...
                    
                    var serviceUrl = layer.url;
                    
                    // Falls es eine Proxy-URL ist, benutze sie direkt mit /query
                    // Der agsproxy leitet an den richtigen Service weiter
                    if (serviceUrl.indexOf('agsproxy.php') > -1) {
                        // URL ist bereits im Proxy-Format: /maps/agsproxy.php/service/MapServer/0
                        // Füge /query direkt an
                        var queryUrl = serviceUrl + '/query';
                        
                        var params = new URLSearchParams({
                            f: 'json',
                            geometry: geometryJson,
                            geometryType: 'esriGeometryPolygon',
                            spatialRel: 'esriSpatialRelIntersects',
                            outFields: '*',
                            returnGeometry: 'true',
                            inSR: '2056',
                            outSR: '2056'
                        });
                        
                        // Proxy-URL mit Query-Parametern
                        var fullUrl = queryUrl + '?' + params.toString();
                        
                        console.log('Query URL für Layer "' + layer.name + '":', fullUrl);
                        
                        fetch(fullUrl)
                            .then(function(response) { 
                                console.log('Response Status:', response.status);
                                return response.json(); 
                            })
                            .then(function(data) {
                                console.log('Response Data für "' + layer.name + '":', data);
                                resolve({
                                    layerName: layer.name,
                                    features: data.features || [],
                                    error: data.error ? data.error.message : null
                                });
                            })
                            .catch(function(err) {
                                console.error('Fetch Error für "' + layer.name + '":', err);
                                resolve({
                                    layerName: layer.name,
                                    features: [],
                                    error: err.message
                                });
                            });
                    } else {
                        // Direkte URL - über Proxy leiten
                        var queryUrl = serviceUrl + '/query';
                        
                        var params = new URLSearchParams({
                            f: 'json',
                            geometry: geometryJson,
                            geometryType: 'esriGeometryPolygon',
                            spatialRel: 'esriSpatialRelIntersects',
                            outFields: '*',
                            returnGeometry: 'true',
                            inSR: '2056',
                            outSR: '2056'
                        });
                        
                        var proxyUrl = '/maps/agsproxy.php?' + encodeURIComponent(queryUrl + '?' + params.toString());
                        
                        console.log('Proxy Query URL für Layer "' + layer.name + '":', proxyUrl);
                        
                        fetch(proxyUrl)
                            .then(function(response) { 
                                console.log('Response Status:', response.status);
                                return response.json(); 
                            })
                            .then(function(data) {
                                console.log('Response Data für "' + layer.name + '":', data);
                                resolve({
                                    layerName: layer.name,
                                    features: data.features || [],
                                    error: data.error ? data.error.message : null
                                });
                            })
                            .catch(function(err) {
                                console.error('Fetch Error für "' + layer.name + '":', err);
                                resolve({
                                    layerName: layer.name,
                                    features: [],
                                    error: err.message
                                });
                            });
                    }
                });
            }
            
            // Sichtbare abfragbare Layer ermitteln
            function getVisibleQueryableLayers() {
                var layers = [];
                
                console.log('=== LAYER DETECTION DEBUG ===');
                
                // Versuche Layer aus dem njs Layer-Manager zu holen
                if (njs && njs.AppManager && njs.AppManager.Maps && njs.AppManager.Maps['main']) {
                    var mapWrapper = njs.AppManager.Maps['main'];
                    var map = mapWrapper.mapObj;
                    
                    console.log('Map gefunden:', !!map);
                    
                    if (map) {
                        var allLayers = map.getLayers().getArray();
                        console.log('Anzahl Layer in Map:', allLayers.length);
                        
                        allLayers.forEach(function(layer, idx) {
                            // Prüfe ob es ein gültiger Layer mit getSource ist
                            if (!layer || typeof layer.getVisible !== 'function' || typeof layer.getSource !== 'function') {
                                console.log('Layer ' + idx + ': Kein gültiger Layer (evtl. LayerGroup)');
                                return;
                            }
                            
                            var visible = layer.getVisible();
                            var source = layer.getSource();
                            var name = layer.get('name') || layer.get('title') || 'Layer ' + idx;
                            var sourceType = source ? source.constructor.name : 'no source';
                            
                            console.log('Layer ' + idx + ':', {
                                name: name,
                                visible: visible,
                                sourceType: sourceType,
                                hasGetUrl: !!(source && source.getUrl),
                                hasGetUrls: !!(source && source.getUrls),
                                hasParams: !!(source && source.getParams)
                            });
                            
                            if (visible && source) {
                                var url = null;
                                
                                // Versuche verschiedene Methoden, die URL zu bekommen
                                if (typeof source.getUrl === 'function') {
                                    url = source.getUrl();
                                } else if (typeof source.getUrls === 'function') {
                                    var urls = source.getUrls();
                                    if (urls && urls.length > 0) url = urls[0];
                                }
                                
                                // Falls source.url_ direkt verfügbar
                                if (!url && source.url_) {
                                    url = source.url_;
                                }
                                
                                // Falls TileArcGISRest oder ImageArcGISRest
                                if (!url && source.urls_ && source.urls_.length > 0) {
                                    url = source.urls_[0];
                                }
                                
                                if (url) {
                                    console.log('  URL:', url);
                                }
                                
                                // Hole auch die Source-Parameter für zusätzliche Infos
                                var sourceParams = null;
                                if (typeof source.getParams === 'function') {
                                    sourceParams = source.getParams();
                                    console.log('  Source Params:', sourceParams);
                                }
                                
                                // Prüfe ob es ein ArcGIS Layer ist (über Proxy oder direkt)
                                // agsproxy.php = ArcGIS Server Proxy
                                var isArcGIS = url && (url.indexOf('agsproxy.php') > -1 || 
                                    (url.indexOf('MapServer') > -1 && url.indexOf('cgi-bin') === -1 && url.indexOf('geo.admin.ch') === -1) || 
                                    url.indexOf('FeatureServer') > -1);
                                
                                // Prüfe ob es ein WMS/MapServer Layer ist (UMN MapServer via cgi-bin)
                                // WICHTIG: Nur wenn es NICHT bereits als ArcGIS erkannt wurde
                                // Schweizer Bundeslayer (geo.admin.ch oder ch.* Layer) werden auch als WMS behandelt
                                var isWMS = false;
                                if (!isArcGIS) {
                                    if (sourceType === 'TileWMS' || sourceType === 'ImageWMS') {
                                        isWMS = true;
                                    }
                                    if (url && (url.indexOf('mapserv') > -1 || url.indexOf('cgi-bin') > -1 || url.indexOf('geo.admin.ch') > -1)) {
                                        isWMS = true;
                                    }
                                    if (sourceParams && sourceParams.SERVICE === 'WMS') {
                                        isWMS = true;
                                    }
                                    // Bundeslayer erkennen (ch.* Layer-Namen)
                                    if (sourceParams && sourceParams.LAYERS && sourceParams.LAYERS.indexOf('ch.') === 0) {
                                        isWMS = true;
                                        console.log('  Schweizer Bundeslayer erkannt (ch.* Layer)');
                                    }
                                }
                                
                                console.log('  Layer-Typ:', isArcGIS ? 'ArcGIS' : (isWMS ? 'WMS/MapServer' : 'Unbekannt'));
                                
                                if (isArcGIS) {
                                    console.log('  ArcGIS Layer erkannt');
                                    
                                    // Extrahiere den Service-Pfad
                                    var serviceUrl = url;
                                    var layerId = null;
                                    
                                    // Verschiedene URL-Formate handhaben:
                                    // 1. /maps/agsproxy.php/gis_oereb/service/MapServer/0
                                    // 2. /maps/agsproxy.php/gis_oereb/service/MapServer (mit LAYERS param)
                                    // 3. https://server/arcgis/rest/services/folder/service/MapServer/0
                                    
                                    // Layer-ID am Ende der URL?
                                    var layerMatch = url.match(/\/(\d+)\/?$/);
                                    if (layerMatch) {
                                        layerId = layerMatch[1];
                                        serviceUrl = url.replace(/\/\d+\/?$/, '');
                                    }
                                    
                                    // Falls LAYERS Parameter vorhanden und keine Layer-ID in URL
                                    if (!layerId && sourceParams && sourceParams.LAYERS) {
                                        var layerStr = sourceParams.LAYERS.replace('show:', '');
                                        var layerIds = layerStr.split(',');
                                        
                                        // Für jeden Layer-ID einen Eintrag erstellen
                                        layerIds.forEach(function(lid) {
                                            var fullUrl = serviceUrl + '/' + lid.trim();
                                            console.log('  -> Layer hinzugefügt:', fullUrl);
                                            layers.push({
                                                name: name + ' (Layer ' + lid + ')',
                                                url: fullUrl,
                                                layerId: lid.trim(),
                                                type: 'arcgis'
                                            });
                                        });
                                    } else if (layerId) {
                                        // Einzelner Layer mit ID in URL
                                        console.log('  -> Layer hinzugefügt:', serviceUrl + '/' + layerId);
                                        layers.push({
                                            name: name,
                                            url: serviceUrl + '/' + layerId,
                                            layerId: layerId,
                                            type: 'arcgis'
                                        });
                                    } else {
                                        // Fallback: Versuche alle Layer des Service abzufragen (Layer 0)
                                        console.log('  -> Fallback Layer 0:', serviceUrl + '/0');
                                        layers.push({
                                            name: name,
                                            url: serviceUrl + '/0',
                                            layerId: '0',
                                            type: 'arcgis'
                                        });
                                    }
                                } else if (isWMS) {
                                    console.log('  WMS Layer erkannt');
                                    
                                    // Extrahiere Basis-URL (ohne Query-Parameter)
                                    var baseUrl = url.split('?')[0];
                                    
                                    // Extrahiere map-Parameter aus der URL (für MapServer)
                                    var mapParam = null;
                                    var urlMapMatch = url.match(/[?&]map=([^&]+)/i);
                                    if (urlMapMatch) {
                                        mapParam = decodeURIComponent(urlMapMatch[1]);
                                        console.log('  MapServer map Parameter:', mapParam);
                                    }
                                    
                                    // Hole LAYERS aus den Params
                                    var wmsLayers = sourceParams && sourceParams.LAYERS ? sourceParams.LAYERS : '';
                                    
                                    // Filtere mask_layer aus (wird nicht abgefragt)
                                    if (wmsLayers && wmsLayers !== 'mask_layer' && wmsLayers.toLowerCase() !== 'mask_layer') {
                                        console.log('  -> WMS Layer hinzugefügt:', baseUrl, 'LAYERS:', wmsLayers);
                                        layers.push({
                                            name: name,
                                            url: baseUrl,
                                            wmsLayers: wmsLayers,
                                            type: 'wms',
                                            sourceParams: sourceParams,
                                            mapParam: mapParam  // MapServer map-Parameter
                                        });
                                    } else if (wmsLayers === 'mask_layer' || wmsLayers.toLowerCase() === 'mask_layer') {
                                        console.log('  -> mask_layer übersprungen (wird nicht abgefragt)');
                                    }
                                }
                            }
                        });
                    }
                }
                
                console.log('Gefundene abfragbare Layer:', layers);
                return layers;
            }
            
            // Highlight-Layer für Feature-Hervorhebung
            var highlightLayer = null;
            var allQueryFeatures = []; // Speichert alle Features für Klick-Zugriff
            
            function getHighlightLayer(map) {
                if (!highlightLayer) {
                    highlightLayer = new ol.layer.Vector({
                        source: new ol.source.Vector(),
                        style: new ol.style.Style({
                            fill: new ol.style.Fill({
                                color: 'rgba(255, 200, 0, 0.4)'
                            }),
                            stroke: new ol.style.Stroke({
                                color: '#ff8c00',
                                width: 3
                            }),
                            image: new ol.style.Circle({
                                radius: 8,
                                fill: new ol.style.Fill({ color: '#ff8c00' }),
                                stroke: new ol.style.Stroke({ color: 'white', width: 2 })
                            })
                        }),
                        zIndex: 1001
                    });
                    map.addLayer(highlightLayer);
                }
                return highlightLayer;
            }
            
            // Feature auf Karte hervorheben
            window.highlightFeature = function(layerIdx, featureIdx) {
                // Map direkt holen
                var map = null;
                if (njs && njs.AppManager && njs.AppManager.Maps && njs.AppManager.Maps['main'] && njs.AppManager.Maps['main'].mapObj) {
                    map = njs.AppManager.Maps['main'].mapObj;
                }
                
                if (!map) {
                    console.warn('Map nicht verfügbar');
                    return;
                }
                
                var layer = getHighlightLayer(map);
                layer.getSource().clear();
                
                // Feature aus gespeicherten Daten holen
                console.log('highlightFeature:', layerIdx, featureIdx, allQueryFeatures);
                
                if (allQueryFeatures[layerIdx] && allQueryFeatures[layerIdx][featureIdx]) {
                    var featureData = allQueryFeatures[layerIdx][featureIdx];
                    var geometry = featureData.geometry;
                    
                    console.log('Feature data:', featureData);
                    console.log('Geometry:', geometry);
                    
                    if (geometry) {
                        var olGeom = null;
                        
                        // ArcGIS Geometrie zu OpenLayers konvertieren
                        if (geometry.rings) {
                            // ArcGIS Polygon
                            olGeom = new ol.geom.Polygon(geometry.rings);
                        } else if (geometry.paths) {
                            // ArcGIS Polyline
                            olGeom = new ol.geom.MultiLineString(geometry.paths);
                        } else if (geometry.x !== undefined && geometry.y !== undefined) {
                            // ArcGIS Point
                            olGeom = new ol.geom.Point([geometry.x, geometry.y]);
                        } else if (geometry.points) {
                            // ArcGIS MultiPoint
                            olGeom = new ol.geom.MultiPoint(geometry.points);
                        }
                        // GeoJSON Geometrien
                        else if (geometry.type === 'Point' && geometry.coordinates) {
                            olGeom = new ol.geom.Point(geometry.coordinates);
                        } else if (geometry.type === 'MultiPoint' && geometry.coordinates) {
                            olGeom = new ol.geom.MultiPoint(geometry.coordinates);
                        } else if (geometry.type === 'LineString' && geometry.coordinates) {
                            olGeom = new ol.geom.LineString(geometry.coordinates);
                        } else if (geometry.type === 'MultiLineString' && geometry.coordinates) {
                            olGeom = new ol.geom.MultiLineString(geometry.coordinates);
                        } else if (geometry.type === 'Polygon' && geometry.coordinates) {
                            olGeom = new ol.geom.Polygon(geometry.coordinates);
                        } else if (geometry.type === 'MultiPolygon' && geometry.coordinates) {
                            olGeom = new ol.geom.MultiPolygon(geometry.coordinates);
                        }
                        
                        if (olGeom) {
                            // LV03 → LV95 Konvertierung falls nötig
                            // LV03: E ~480'000-840'000, N ~75'000-300'000
                            // LV95: E ~2'480'000-2'840'000, N ~1'075'000-1'300'000
                            var coords = olGeom.getFirstCoordinate();
                            var isLV03 = coords && 
                                coords[0] > 400000 && coords[0] < 900000 && 
                                coords[1] > 50000 && coords[1] < 400000;
                            if (isLV03) {
                                console.log('LV03 Koordinaten erkannt, konvertiere zu LV95:', coords);
                                olGeom.applyTransform(function(input, output, dim) {
                                    var d = dim || 2;
                                    for (var i = 0; i < input.length; i += d) {
                                        output[i] = input[i] + 2000000;
                                        output[i + 1] = input[i + 1] + 1000000;
                                        // Weitere Dimensionen (z.B. Z) unverändert lassen
                                        for (var j = 2; j < d; j++) {
                                            output[i + j] = input[i + j];
                                        }
                                    }
                                    return output;
                                });
                                console.log('Konvertiert zu LV95:', olGeom.getFirstCoordinate());
                            }
                            
                            var feature = new ol.Feature({ geometry: olGeom });
                            layer.getSource().addFeature(feature);
                            
                            // Zur Geometrie zoomen
                            var extent = olGeom.getExtent();
                            
                            // Bei Punkten oder sehr kleinen Extents: Mindestgrösse setzen
                            var minSize = 100; // Mindestens 100m in jede Richtung
                            var width = extent[2] - extent[0];
                            var height = extent[3] - extent[1];
                            if (width < minSize || height < minSize) {
                                var centerX = (extent[0] + extent[2]) / 2;
                                var centerY = (extent[1] + extent[3]) / 2;
                                extent = [
                                    centerX - minSize,
                                    centerY - minSize,
                                    centerX + minSize,
                                    centerY + minSize
                                ];
                            }
                            
                            map.getView().fit(extent, {
                                padding: [50, 50, 50, 50],
                                duration: 500
                            });
                        }
                    }
                }
            };
            
            // Highlight entfernen
            window.clearHighlight = function() {
                if (highlightLayer) {
                    highlightLayer.getSource().clear();
                }
            };
            
            // Ergebnisse anzeigen
            function displayResults(results, layers) {
                var statusEl = document.getElementById('spatial-query-status');
                var resultsEl = document.getElementById('spatial-query-results');
                
                // Features für späteren Zugriff speichern
                allQueryFeatures = results.map(function(r) { return r.features || []; });
                
                // Filtere mask_layer aus den Ergebnissen aus
                results = results.filter(function(result) {
                    return result.layerName !== 'mask_layer (WFS)' && 
                           result.layerName.toLowerCase().indexOf('mask_layer') === -1;
                });
                
                // Layer in Kategorien einteilen
                var layersWithResults = [];
                var layersWithoutResults = [];
                var layersNotQueryable = [];
                
                results.forEach(function(result, layerIdx) {
                    var count = result.features ? result.features.length : 0;
                    
                    if (result.error && (result.error.indexOf('WFS nicht verfügbar') > -1 || result.error.indexOf('nicht unterstützt') > -1)) {
                        layersNotQueryable.push({ result: result, layerIdx: layerIdx });
                    } else if (count === 0 && !result.error) {
                        layersWithoutResults.push({ result: result, layerIdx: layerIdx });
                    } else if (count > 0) {
                        layersWithResults.push({ result: result, layerIdx: layerIdx });
                    } else {
                        // Fehler - zu layersNotQueryable
                        layersNotQueryable.push({ result: result, layerIdx: layerIdx });
                    }
                });
                
                var totalFeatures = layersWithResults.reduce(function(sum, item) {
                    return sum + (item.result.features ? item.result.features.length : 0);
                }, 0);
                
                var html = '';
                
                // 1. Layer mit Resultaten
                layersWithResults.forEach(function(item) {
                    var result = item.result;
                    var layerIdx = item.layerIdx;
                    var count = result.features.length;
                    
                    html += '<div class="query-result-layer">';
                    html += '<div class="query-result-header" onclick="toggleQueryResult(this)">';
                    html += '<span class="query-result-icon">▶</span>';
                    html += '<span class="query-result-name">' + result.layerName + '</span>';
                    html += '<span class="query-result-count">' + count + '</span>';
                    html += '</div>';
                    html += '<div class="query-result-content hidden">';
                    html += '<table class="query-result-table">';
                    
                    // Header
                    var attrs = result.features[0].attributes;
                    var keys = Object.keys(attrs).slice(0, 6); // Max 6 Spalten
                    html += '<thead><tr>';
                    html += '<th></th>'; // Spalte für Zoom-Button
                    keys.forEach(function(key) {
                        html += '<th>' + key + '</th>';
                    });
                    html += '</tr></thead>';
                    
                    // Daten (max 50 Zeilen)
                    html += '<tbody>';
                    result.features.slice(0, 50).forEach(function(feature, featureIdx) {
                        var hasGeom = feature.geometry ? 'true' : 'false';
                        html += '<tr class="query-result-row" data-layer="' + layerIdx + '" data-feature="' + featureIdx + '" onclick="highlightFeature(' + layerIdx + ',' + featureIdx + ')">';
                        html += '<td class="zoom-cell"><span class="zoom-icon" title="In Karte zeigen"><svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"/><line x1="12" y1="2" x2="12" y2="6"/><line x1="12" y1="18" x2="12" y2="22"/><line x1="2" y1="12" x2="6" y2="12"/><line x1="18" y1="12" x2="22" y2="12"/></svg></span></td>';
                        keys.forEach(function(key) {
                            var val = feature.attributes[key];
                            if (val === null || val === undefined) val = '-';
                            html += '<td>' + val + '</td>';
                        });
                        html += '</tr>';
                    });
                    html += '</tbody></table>';
                    
                    if (count > 50) {
                        html += '<p class="more-results">... und ' + (count - 50) + ' weitere</p>';
                    }
                    html += '</div>';
                    html += '</div>';
                });
                
                // 2. Accordion für Layer ohne Treffer
                if (layersWithoutResults.length > 0) {
                    html += '<div class="query-result-layer query-result-empty">';
                    html += '<div class="query-result-header" onclick="toggleQueryResult(this)">';
                    html += '<span class="query-result-icon">▶</span>';
                    html += '<span class="query-result-name">Keine Objekte gefunden</span>';
                    html += '<span class="query-result-count">' + layersWithoutResults.length + '</span>';
                    html += '</div>';
                    html += '<div class="query-result-content hidden">';
                    html += '<ul class="empty-layers-list">';
                    layersWithoutResults.forEach(function(item) {
                        html += '<li>' + item.result.layerName + '</li>';
                    });
                    html += '</ul>';
                    html += '</div>';
                    html += '</div>';
                }
                
                // 3. Accordion für nicht abfragbare Layer
                if (layersNotQueryable.length > 0) {
                    html += '<div class="query-result-layer query-result-not-queryable">';
                    html += '<div class="query-result-header" onclick="toggleQueryResult(this)">';
                    html += '<span class="query-result-icon">▶</span>';
                    html += '<span class="query-result-name">Räumliche Abfrage nicht unterstützt</span>';
                    html += '<span class="query-result-count">' + layersNotQueryable.length + '</span>';
                    html += '</div>';
                    html += '<div class="query-result-content hidden">';
                    html += '<ul class="not-queryable-layers-list">';
                    layersNotQueryable.forEach(function(item) {
                        var errorMsg = item.result.error || 'Unbekannter Fehler';
                        html += '<li>' + item.result.layerName + ' <span class="error-hint">(' + errorMsg + ')</span></li>';
                    });
                    html += '</ul>';
                    html += '</div>';
                    html += '</div>';
                }
                
                statusEl.textContent = totalFeatures + ' Objekte in ' + layersWithResults.length + ' Layer(n) gefunden';
                resultsEl.innerHTML = html;
            }
            
            // Ergebnis auf-/zuklappen
            window.toggleQueryResult = function(header) {
                var content = header.nextElementSibling;
                var icon = header.querySelector('.query-result-icon');
                
                if (content.classList.contains('hidden')) {
                    content.classList.remove('hidden');
                    icon.textContent = '▼';
                } else {
                    content.classList.add('hidden');
                    icon.textContent = '▶';
                }
            };
            
            // Excel Export
            window.exportQueryToExcel = function() {
                if (!allQueryFeatures || allQueryFeatures.length === 0) {
                    alert('Keine Daten zum Exportieren vorhanden.');
                    return;
                }
                
                var csvContent = '';
                var hasData = false;
                
                allQueryFeatures.forEach(function(features, layerIdx) {
                    if (features && features.length > 0) {
                        hasData = true;
                        
                        // Layer-Name als Überschrift
                        var layerName = document.querySelectorAll('.query-result-name')[layerIdx];
                        csvContent += '\n"' + (layerName ? layerName.textContent : 'Layer ' + layerIdx) + '"\n';
                        
                        // Header
                        var attrs = features[0].attributes;
                        var keys = Object.keys(attrs);
                        csvContent += keys.map(function(k) { return '"' + k + '"'; }).join(';') + '\n';
                        
                        // Daten
                        features.forEach(function(feature) {
                            var row = keys.map(function(key) {
                                var val = feature.attributes[key];
                                if (val === null || val === undefined) val = '';
                                // Escape quotes
                                val = String(val).replace(/"/g, '""');
                                return '"' + val + '"';
                            });
                            csvContent += row.join(';') + '\n';
                        });
                    }
                });
                
                if (!hasData) {
                    alert('Keine Daten zum Exportieren vorhanden.');
                    return;
                }
                
                // BOM für UTF-8 hinzufügen
                var BOM = '\uFEFF';
                var blob = new Blob([BOM + csvContent], { type: 'text/csv;charset=utf-8;' });
                var url = URL.createObjectURL(blob);
                var link = document.createElement('a');
                link.href = url;
                link.download = 'raeumliche_abfrage_' + new Date().toISOString().slice(0,10) + '.csv';
                link.click();
                URL.revokeObjectURL(url);
            };
            
            // Panel andocken (unten)
            window.isPanelDocked = false;  // Globale Variable für Drag/Resize Checks
            window.toggleDockPanel = function() {
                var panel = document.getElementById('spatial-query-panel');
                var dockBtn = document.getElementById('dock-btn');
                var freepane = document.getElementById('freepane');
                
                if (window.isPanelDocked) {
                    // Undock - zurück zu floating
                    panel.classList.remove('docked-bottom');
                    panel.style.left = '';
                    panel.style.top = '';
                    panel.style.height = '';
                    dockBtn.innerHTML = '<svg viewBox="0 0 24 24" width="16" height="16"><path fill="currentColor" d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5v-3h14v3zm0-5H5V5h14v9z"/></svg>';
                    dockBtn.title = 'Unten andocken';
                    window.isPanelDocked = false;
                    // Freepane wieder auf volle Höhe
                    if (freepane) {
                        freepane.classList.remove('panel-docked');
                        freepane.style.bottom = '';
                    }
                } else {
                    // Dock - unten andocken
                    panel.classList.add('docked-bottom');
                    panel.style.left = '';
                    panel.style.top = '';
                    dockBtn.innerHTML = '<svg viewBox="0 0 24 24" width="16" height="16"><path fill="currentColor" d="M19 11h-8v6h8v-6zm4 8V4.98C23 3.88 22.1 3 21 3H3c-1.1 0-2 .88-2 1.98V19c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2zm-2 .02H3V4.97h18v14.05z"/></svg>';
                    dockBtn.title = 'Floating';
                    window.isPanelDocked = true;
                    // Freepane kürzen bis Panel-Oberkante
                    if (freepane) {
                        freepane.classList.add('panel-docked');
                        // Kurze Verzögerung damit Panel-Höhe korrekt berechnet wird
                        setTimeout(function() {
                            updateFreepaneHeight();
                        }, 50);
                    }
                }
            };
            
            // Freepane-Höhe anpassen wenn Panel angedockt
            window.updateFreepaneHeight = function() {
                var panel = document.getElementById('spatial-query-panel');
                var freepane = document.getElementById('freepane');
                if (panel && freepane && window.isPanelDocked) {
                    var panelHeight = panel.offsetHeight;
                    freepane.style.bottom = (panelHeight + 32) + 'px'; // +32 für footer-bar
                }
            };
        })();
    </script>

    <!-- Ergebnis-Panel für räumliche Abfrage (ausserhalb mapContainer für korrekte Pointer-Events) -->
    <div id="spatial-query-panel" class="spatial-query-panel hidden">
        <div class="spatial-query-resize-top" id="spatial-query-resize-top"></div>
        <div class="spatial-query-resize-left" id="spatial-query-resize-left"></div>
        <div class="spatial-query-resize-right" id="spatial-query-resize-right"></div>
        <div class="spatial-query-resize-bottom" id="spatial-query-resize-bottom"></div>
        <div class="spatial-query-resize-corner-tl" id="spatial-query-resize-corner-tl"></div>
        <div class="spatial-query-resize-corner-tr" id="spatial-query-resize-corner-tr"></div>
        <div class="spatial-query-resize-corner-bl" id="spatial-query-resize-corner-bl"></div>
        <div class="spatial-query-resize-corner-br" id="spatial-query-resize-corner-br"></div>
        <div class="spatial-query-header" id="spatial-query-header">
            <span class="spatial-query-title">Räumliche Abfrage</span>
            <div class="spatial-query-actions">
                <button class="spatial-query-btn" onclick="exportQueryToExcel()" title="Als Excel exportieren">
                    <svg viewBox="0 0 24 24" width="16" height="16"><path fill="currentColor" d="M14 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V8l-6-6zm4 18H6V4h7v5h5v11zm-5-7l-3 3.5L7 13h2.5V9h3v4H15z"/></svg>
                </button>
                <button class="spatial-query-btn" onclick="toggleDockPanel()" title="Unten andocken" id="dock-btn">
                    <svg viewBox="0 0 24 24" width="16" height="16"><path fill="currentColor" d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5v-3h14v3zm0-5H5V5h14v9z"/></svg>
                </button>
                <button class="spatial-query-close" onclick="closeSpatialQueryPanel()">&times;</button>
            </div>
        </div>
        <div class="spatial-query-status" id="spatial-query-status">Zeichnen Sie ein Polygon auf der Karte...</div>
        <div class="spatial-query-results" id="spatial-query-results"></div>
    </div>

    <!-- Panel Drag & Resize Initialisierung (NACH dem Panel-Element) -->
    <script>
    (function() {
        // Panel verschiebbar machen
        var panel = document.getElementById('spatial-query-panel');
        var header = document.getElementById('spatial-query-header');
        
        if (!panel || !header) {
            console.error('Spatial Query Panel oder Header nicht gefunden!');
            return;
        }
        
        var isDragging = false;
        var startX, startY, startLeft, startTop;
        
        header.addEventListener('mousedown', function(e) {
            // Nicht draggen wenn auf Button geklickt
            if (e.target.closest('button')) return;
            if (window.isPanelDocked) return;
            
            isDragging = true;
            
            var rect = panel.getBoundingClientRect();
            startX = e.clientX;
            startY = e.clientY;
            startLeft = rect.left;
            startTop = rect.top;
            
            panel.style.right = 'auto';
            panel.style.left = startLeft + 'px';
            panel.style.top = startTop + 'px';
            
            e.preventDefault();
        });
        
        document.addEventListener('mousemove', function(e) {
            if (!isDragging) return;
            
            var dx = e.clientX - startX;
            var dy = e.clientY - startY;
            
            panel.style.left = (startLeft + dx) + 'px';
            panel.style.top = (startTop + dy) + 'px';
        });
        
        document.addEventListener('mouseup', function() {
            isDragging = false;
        });
        
        // ===== RESIZE FUNCTIONALITY =====
        var isResizing = false;
        var resizeDirection = '';
        var resizeStartX, resizeStartY, resizeStartWidth, resizeStartHeight, resizeStartLeft, resizeStartTop;
        
        // Resize-Handles
        var handles = {
            top: document.getElementById('spatial-query-resize-top'),
            left: document.getElementById('spatial-query-resize-left'),
            right: document.getElementById('spatial-query-resize-right'),
            bottom: document.getElementById('spatial-query-resize-bottom'),
            tl: document.getElementById('spatial-query-resize-corner-tl'),
            tr: document.getElementById('spatial-query-resize-corner-tr'),
            bl: document.getElementById('spatial-query-resize-corner-bl'),
            br: document.getElementById('spatial-query-resize-corner-br')
        };
        
        function startResize(e, direction) {
            if (window.isPanelDocked && direction !== 'top') return; // Im angedockten Modus nur oben
            
            isResizing = true;
            resizeDirection = direction;
            resizeStartX = e.clientX;
            resizeStartY = e.clientY;
            
            var rect = panel.getBoundingClientRect();
            resizeStartWidth = rect.width;
            resizeStartHeight = rect.height;
            resizeStartLeft = rect.left;
            resizeStartTop = rect.top;
            
            document.body.style.userSelect = 'none';
            e.preventDefault();
            e.stopPropagation();
        }
        
        // Mousedown Handler für alle Handles
        if (handles.top) {
            handles.top.addEventListener('mousedown', function(e) { startResize(e, 'top'); });
        }
        if (handles.left) {
            handles.left.addEventListener('mousedown', function(e) { startResize(e, 'left'); });
        }
        if (handles.right) {
            handles.right.addEventListener('mousedown', function(e) { startResize(e, 'right'); });
        }
        if (handles.bottom) {
            handles.bottom.addEventListener('mousedown', function(e) { startResize(e, 'bottom'); });
        }
        if (handles.tl) {
            handles.tl.addEventListener('mousedown', function(e) { startResize(e, 'tl'); });
        }
        if (handles.tr) {
            handles.tr.addEventListener('mousedown', function(e) { startResize(e, 'tr'); });
        }
        if (handles.bl) {
            handles.bl.addEventListener('mousedown', function(e) { startResize(e, 'bl'); });
        }
        if (handles.br) {
            handles.br.addEventListener('mousedown', function(e) { startResize(e, 'br'); });
        }
        
        document.addEventListener('mousemove', function(e) {
            if (!isResizing) return;
            
            var dx = e.clientX - resizeStartX;
            var dy = e.clientY - resizeStartY;
            
            var newWidth = resizeStartWidth;
            var newHeight = resizeStartHeight;
            var newLeft = resizeStartLeft;
            var newTop = resizeStartTop;
            
            // Angedockt: nur Höhe ändern
            if (window.isPanelDocked) {
                newHeight = Math.max(150, Math.min(resizeStartHeight - dy, window.innerHeight - 100));
                panel.style.height = newHeight + 'px';
                if (window.updateFreepaneHeight) {
                    window.updateFreepaneHeight();
                }
                return;
            }
            
            // Freischwebend: alle Richtungen
            switch(resizeDirection) {
                case 'top':
                    newHeight = Math.max(200, resizeStartHeight - dy);
                    newTop = resizeStartTop + (resizeStartHeight - newHeight);
                    panel.style.height = newHeight + 'px';
                    panel.style.top = newTop + 'px';
                    break;
                case 'bottom':
                    newHeight = Math.max(200, resizeStartHeight + dy);
                    panel.style.height = newHeight + 'px';
                    break;
                case 'left':
                    newWidth = Math.max(300, resizeStartWidth - dx);
                    newLeft = resizeStartLeft + (resizeStartWidth - newWidth);
                    panel.style.width = newWidth + 'px';
                    panel.style.left = newLeft + 'px';
                    break;
                case 'right':
                    newWidth = Math.max(300, resizeStartWidth + dx);
                    panel.style.width = newWidth + 'px';
                    break;
                case 'tl':
                    newWidth = Math.max(300, resizeStartWidth - dx);
                    newHeight = Math.max(200, resizeStartHeight - dy);
                    newLeft = resizeStartLeft + (resizeStartWidth - newWidth);
                    newTop = resizeStartTop + (resizeStartHeight - newHeight);
                    panel.style.width = newWidth + 'px';
                    panel.style.height = newHeight + 'px';
                    panel.style.left = newLeft + 'px';
                    panel.style.top = newTop + 'px';
                    break;
                case 'tr':
                    newWidth = Math.max(300, resizeStartWidth + dx);
                    newHeight = Math.max(200, resizeStartHeight - dy);
                    newTop = resizeStartTop + (resizeStartHeight - newHeight);
                    panel.style.width = newWidth + 'px';
                    panel.style.height = newHeight + 'px';
                    panel.style.top = newTop + 'px';
                    break;
                case 'bl':
                    newWidth = Math.max(300, resizeStartWidth - dx);
                    newHeight = Math.max(200, resizeStartHeight + dy);
                    newLeft = resizeStartLeft + (resizeStartWidth - newWidth);
                    panel.style.width = newWidth + 'px';
                    panel.style.height = newHeight + 'px';
                    panel.style.left = newLeft + 'px';
                    break;
                case 'br':
                    newWidth = Math.max(300, resizeStartWidth + dx);
                    newHeight = Math.max(200, resizeStartHeight + dy);
                    panel.style.width = newWidth + 'px';
                    panel.style.height = newHeight + 'px';
                    break;
            }
        });
        
        document.addEventListener('mouseup', function() {
            if (isResizing) {
                isResizing = false;
                resizeDirection = '';
                document.body.style.userSelect = '';
                if (window.isPanelDocked && window.updateFreepaneHeight) {
                    window.updateFreepaneHeight();
                }
            }
        });
    })();
    </script>

</body>